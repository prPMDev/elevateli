/**
 * ElevateLI Content Script - Auto-generated Bundle
 * Generated on: 2025-07-07T19:40:14.567Z
 * DO NOT EDIT THIS FILE DIRECTLY - Edit the source modules instead
 */

(function() {
  'use strict';


  /* ============================================
   * MODULE: constants.js
   * ============================================ */
/**
 * Constants used throughout the ElevateLI extension
 */

// Timing constants
const TIMINGS = {
  DEBOUNCE_DELAY: 1000,
  EXTRACTION_THROTTLE: 5000,
  ELEMENT_WAIT_TIMEOUT: 5000,
  ELEMENT_CHECK_INTERVAL: 100,
  MODAL_WAIT_DELAY: 1500,
  OVERLAY_ANIMATION_DELAY: 500,
  BADGE_INJECT_DELAY: 500
};

// Score thresholds
const SCORE_THRESHOLDS = {
  HIGH: 8,
  MEDIUM: 6,
  COMPLETENESS_HIGH: 85,
  COMPLETENESS_MEDIUM: 60,
  HEADLINE_MIN_CHARS: 100,
  ABOUT_MIN_CHARS: 500,
  ABOUT_OPTIMAL_CHARS: 1500,
  MIN_SKILLS: 10
};

// Character limits for profile sections
const CHAR_LIMITS = {
  HEADLINE: 220,
  ABOUT: 2600,
  EXPERIENCE_OPTIMAL: 1500
};

// Cache settings
const CACHE_SETTINGS = {
  MAX_AGE_DAYS: 7,
  DEFAULT_DURATION_DAYS: 7
};

// UI Colors
const COLORS = {
  HIGH_SCORE: '#057642',
  MEDIUM_SCORE: '#f59e0b',
  LOW_SCORE: '#dc2626',
  LINKEDIN_BLUE: '#0077B5',
  OWN_PROFILE: '#057642'
};

// Selectors
const SELECTORS = {
  PROFILE_ACTIONS: '.pvs-profile-actions--overflow, .pv-top-card-v2-ctas__custom',
  PROFILE_PHOTO: '.pv-top-card-profile-picture img, .profile-photo-edit__preview',
  HEADLINE_EDIT: '.pv-text-details__left-panel h1, .text-body-medium',
  ABOUT_SECTION: 'section[data-section="summary"]',
  EXPERIENCE_SECTION: 'section#experience-section, div[data-view-name="profile-card"][id*="experience"]',
  SKILLS_SECTION: 'section[data-section="skills"], div[data-view-name="profile-card"][id*="skills"]',
  EDUCATION_SECTION: 'section#education-section, div[data-view-name="profile-card"][id*="education"]'
};

// Extension configuration
const CONFIG = {
  EXTENSION_NAME: 'ElevateLI',
  DEBUG_MODE: false
};


  /* ============================================
   * MODULE: state.js
   * ============================================ */
/**
 * State management for the ElevateLI extension
 */

const ExtensionState = {
  isExtracting: false,
  lastExtraction: null,
  badgeInjected: false,
  lastPath: location.pathname,
  observers: [],
  eventListeners: [],
  timeouts: [],
  intervals: [],
  lastCompletenessScore: 0,
  storageListener: null
};

/**
 * Reset state flags
 */
function resetState() {
  ExtensionState.isExtracting = false;
  ExtensionState.badgeInjected = false;
  ExtensionState.lastExtraction = null;
}

/**
 * Update navigation state
 */
function updateNavigationState(newPath) {
  ExtensionState.lastPath = newPath;
  ExtensionState.badgeInjected = false;
}


  /* ============================================
   * MODULE: chromeUtils.js
   * ============================================ */
/**
 * Chrome API utility functions
 */

/**
 * Check if Chrome APIs are available
 */
function safeChrome() {
  return typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.id;
}

/**
 * Send message to extension with error handling
 */
function safeSendMessage(message, callback) {
  if (!safeChrome()) {
    console.error('Chrome APIs not available');
    if (callback) callback(null);
    return;
  }
  
  try {
    if (callback) {
      chrome.runtime.sendMessage(message, callback);
    } else {
      chrome.runtime.sendMessage(message);
    }
  } catch (error) {
    console.error('Error sending message:', error);
    if (callback) callback(null);
  }
}

/**
 * Get data from Chrome storage
 */
function safeStorageGet(keys, callback) {
  if (!safeChrome() || !chrome.storage || !chrome.storage.local) {
    console.error('Chrome storage not available');
    callback({});
    return;
  }
  
  try {
    chrome.storage.local.get(keys, callback);
  } catch (error) {
    console.error('Error getting storage:', error);
    callback({});
  }
}

/**
 * Set data in Chrome storage
 */
function safeStorageSet(data, callback) {
  if (!safeChrome() || !chrome.storage || !chrome.storage.local) {
    console.error('Chrome storage not available');
    if (callback) callback();
    return;
  }
  
  try {
    if (callback) {
      chrome.storage.local.set(data, callback);
    } else {
      chrome.storage.local.set(data);
    }
  } catch (error) {
    console.error('Error setting storage:', error);
    if (callback) callback();
  }
}

/**
 * Get storage data as Promise
 */
function getStorageData(keys) {
  return new Promise((resolve) => {
    safeStorageGet(keys, (data) => {
      resolve(data || {});
    });
  });
}

/**
 * Set storage data as Promise
 */
function setStorageData(data) {
  return new Promise((resolve) => {
    safeStorageSet(data, () => {
      resolve();
    });
  });
}


  /* ============================================
   * MODULE: memoryManager.js
   * ============================================ */
/**
 * Memory management utilities for preventing memory leaks
 */


/**
 * Add a managed event listener that can be cleaned up later
 */
function addManagedEventListener(element, event, handler, options) {
  if (!element) return;
  
  // Remove any existing listener with same signature
  removeManagedEventListener(element, event, handler);
  
  element.addEventListener(event, handler, options);
  ExtensionState.eventListeners.push({ element, event, handler, options });
}

/**
 * Remove a managed event listener
 */
function removeManagedEventListener(element, event, handler) {
  if (!element) return;
  
  element.removeEventListener(event, handler);
  ExtensionState.eventListeners = ExtensionState.eventListeners.filter(
    listener => !(listener.element === element && listener.event === event && listener.handler === handler)
  );
}

/**
 * Add a managed timeout that can be cleaned up later
 */
function addManagedTimeout(callback, delay) {
  const timeoutId = setTimeout(() => {
    callback();
    ExtensionState.timeouts = ExtensionState.timeouts.filter(id => id !== timeoutId);
  }, delay);
  ExtensionState.timeouts.push(timeoutId);
  return timeoutId;
}

/**
 * Clear a managed timeout
 */
function clearManagedTimeout(timeoutId) {
  clearTimeout(timeoutId);
  ExtensionState.timeouts = ExtensionState.timeouts.filter(id => id !== timeoutId);
}

/**
 * Add a managed interval that can be cleaned up later
 */
function addManagedInterval(callback, delay) {
  const intervalId = setInterval(callback, delay);
  ExtensionState.intervals.push(intervalId);
  return intervalId;
}

/**
 * Clear a managed interval
 */
function clearManagedInterval(intervalId) {
  clearInterval(intervalId);
  ExtensionState.intervals = ExtensionState.intervals.filter(id => id !== intervalId);
}

/**
 * Comprehensive cleanup function
 */
function cleanup() {
  // Disconnect all mutation observers
  ExtensionState.observers.forEach(obs => {
    try {
      obs.disconnect();
    } catch (e) {
      console.error('Error disconnecting observer:', e);
    }
  });
  ExtensionState.observers = [];
  
  // Remove all event listeners
  ExtensionState.eventListeners.forEach(({ element, event, handler, options }) => {
    try {
      element.removeEventListener(event, handler, options);
    } catch (e) {
      console.error('Error removing event listener:', e);
    }
  });
  ExtensionState.eventListeners = [];
  
  // Clear all timeouts
  ExtensionState.timeouts.forEach(timeoutId => {
    try {
      clearTimeout(timeoutId);
    } catch (e) {
      console.error('Error clearing timeout:', e);
    }
  });
  ExtensionState.timeouts = [];
  
  // Clear all intervals
  ExtensionState.intervals.forEach(intervalId => {
    try {
      clearInterval(intervalId);
    } catch (e) {
      console.error('Error clearing interval:', e);
    }
  });
  ExtensionState.intervals = [];
  
  // Remove storage listener if exists
  if (ExtensionState.storageListener && chrome?.storage?.onChanged) {
    chrome.storage.onChanged.removeListener(ExtensionState.storageListener);
    ExtensionState.storageListener = null;
  }
  
  // Reset state flags
  ExtensionState.badgeInjected = false;
  ExtensionState.isExtracting = false;
}


  /* ============================================
   * MODULE: domUtils.js
   * ============================================ */
/**
 * DOM utility functions
 */

// Note: TIMINGS, addManagedTimeout, and clearManagedTimeout are assumed to be available in global scope
// from previously loaded modules in the concatenated analyzer.js

/**
 * Debounce function to limit execution frequency
 */
function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

/**
 * Wait for an element to appear in the DOM
 */
function waitForElement(selector, callback, maxWait = TIMINGS.ELEMENT_WAIT_TIMEOUT) {
  const startTime = Date.now();
  let timeoutId = null;
  
  const checkElement = () => {
    const element = document.querySelector(selector);
    if (element) {
      if (timeoutId) clearManagedTimeout(timeoutId);
      callback(element);
    } else if (Date.now() - startTime < maxWait) {
      timeoutId = addManagedTimeout(checkElement, TIMINGS.ELEMENT_CHECK_INTERVAL);
    }
  };
  
  checkElement();
}

/**
 * Check if current page is a LinkedIn profile page
 */
function isProfilePage() {
  const path = window.location.pathname;
  return path.includes('/in/') && !path.includes('/messaging/') && !path.includes('/jobs/');
}

/**
 * Check if viewing own profile
 */
async function isOwnProfile() {
  const currentProfileId = extractProfileIdFromUrl();
  if (!currentProfileId) return false;
  
  // First, check saved profile
  const savedProfile = await getSavedProfile();
  if (savedProfile?.profileId === currentProfileId) {
    console.log('[INFO] Matched saved profile:', savedProfile.profileId);
    return true;
  }
  
  // Check if URL contains /in/me/ (LinkedIn's "view your own profile" URL)
  if (window.location.pathname.includes('/in/me/')) {
    console.log('[INFO] Detected /in/me/ URL, saving profile');
    await saveUserProfileId();
    return true;
  }
  
  // If no saved profile yet, check for ownership indicators
  if (!savedProfile) {
    const hasIndicators = await detectOwnProfileIndicators();
    if (hasIndicators) {
      console.log('[INFO] Profile ownership indicators detected, saving profile');
      await saveUserProfileId();
      return true;
    }
  }
  
  return false;
}

/**
 * Extract profile ID from current URL
 */
function extractProfileIdFromUrl() {
  const match = window.location.pathname.match(/\/in\/([^\/]+)/);
  return match ? match[1] : null;
}

/**
 * Get saved user profile from storage
 */
async function getSavedProfile() {
  return new Promise((resolve) => {
    // Check if chrome APIs are available
    if (!chrome?.storage?.local) {
      resolve(null);
      return;
    }
    
    // Check if extension context is still valid
    if (!chrome.runtime?.id) {
      console.warn('[WARN] Extension context invalidated');
      resolve(null);
      return;
    }
    
    try {
      chrome.storage.local.get(['userProfile'], (data) => {
        // Check for runtime errors
        if (chrome.runtime.lastError) {
          console.warn('[WARN] Chrome storage error:', chrome.runtime.lastError);
          resolve(null);
          return;
        }
        resolve(data.userProfile || null);
      });
    } catch (error) {
      console.warn('[WARN] Error accessing chrome storage:', error);
      resolve(null);
    }
  });
}

/**
 * Detect profile ownership indicators on the page
 */
async function detectOwnProfileIndicators() {
  // Wait a bit for page to load if needed
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  // Check for edit intro button (LinkedIn uses "Edit intro" not "Edit profile")
  const editButton = document.querySelector('button[aria-label*="Edit intro"]') ||
                     document.querySelector('a[href*="/edit/intro/"]') ||
                     document.querySelector('.pvs-profile-actions__edit-profile') ||
                     Array.from(document.querySelectorAll('button')).find(btn => 
                       btn.getAttribute('aria-label')?.includes('Edit'));
  
  // Check for "Add profile section" button
  const addSectionButton = document.querySelector('button[aria-label*="Add profile section"]') ||
                          document.querySelector('a[href*="add-edit/"]') ||
                          Array.from(document.querySelectorAll('button')).find(btn => 
                            btn.textContent?.includes('Add profile section'));
  
  // Check for analytics button (only on own profile)
  const analyticsButton = document.querySelector('button[aria-label*="View profile analytics"]') ||
                         document.querySelector('a[href*="/dashboard/"]') ||
                         Array.from(document.querySelectorAll('button')).find(btn => 
                           btn.textContent?.includes('View profile analytics'));
  
  // Check for Resources button (another ownership indicator)
  const resourcesButton = Array.from(document.querySelectorAll('button')).find(btn => 
                         btn.textContent?.trim() === 'Resources');
  
  // Check if any ownership indicator exists
  const hasOwnershipIndicator = !!(editButton || addSectionButton || analyticsButton || resourcesButton);
  
  if (hasOwnershipIndicator) {
    console.log('[INFO] Profile ownership indicators found:', {
      editButton: !!editButton,
      addSectionButton: !!addSectionButton,
      analyticsButton: !!analyticsButton,
      resourcesButton: !!resourcesButton
    });
  }
  
  return hasOwnershipIndicator;
}

/**
 * Save user's profile ID when detected
 */
async function saveUserProfileId() {
  let profileId = extractProfileIdFromUrl();
  
  // If it's /in/me/, wait for redirect to actual profile
  if (profileId === 'me') {
    console.log('[INFO] Detected /in/me/ URL, waiting for redirect...');
    
    // Wait up to 3 seconds for redirect
    let attempts = 0;
    while (profileId === 'me' && attempts < 6) {
      await new Promise(resolve => setTimeout(resolve, 500));
      profileId = extractProfileIdFromUrl();
      attempts++;
    }
    
    // If still 'me' after waiting, can't save
    if (profileId === 'me') {
      console.log('[WARN] URL still shows /in/me/ after waiting, cannot save profile');
      return;
    }
  }
  
  if (!profileId) return;
  
  // Get profile name from the page
  const profileNameElement = document.querySelector('h1.text-heading-xlarge');
  const profileName = profileNameElement ? profileNameElement.textContent.trim() : profileId;
  
  const userProfile = {
    profileId,
    profileName,
    profileUrl: window.location.href.split('?')[0],
    savedAt: Date.now(),
    verifiedOwnership: true // Auto-detected profiles are verified
  };
  
  try {
    // Check if chrome storage is available
    if (!chrome?.storage?.local) {
      console.warn('[WARN] Chrome storage not available, cannot save profile');
      return;
    }
    
    await chrome.storage.local.set({ userProfile });
    console.log('[INFO] User profile saved:', userProfile);
  } catch (error) {
    console.error('[ERROR] Failed to save user profile:', error);
  }
}

/**
 * Extract text content safely
 */
function extractTextContent(element, maxLength = null) {
  if (!element) return '';
  
  const text = element.textContent?.trim() || '';
  return maxLength ? text.substring(0, maxLength) : text;
}

/**
 * Find element by multiple selectors
 */
function findElement(selectors) {
  if (!Array.isArray(selectors)) {
    selectors = [selectors];
  }
  
  for (const selector of selectors) {
    const element = document.querySelector(selector);
    if (element) return element;
  }
  
  return null;
}

/**
 * Create DOM element with attributes and children
 */
function createElement(tag, attributes = {}, children = []) {
  const element = document.createElement(tag);
  
  // Set attributes
  Object.entries(attributes).forEach(([key, value]) => {
    if (key === 'className') {
      element.className = value;
    } else if (key === 'style' && typeof value === 'object') {
      Object.assign(element.style, value);
    } else if (key.startsWith('on') && typeof value === 'function') {
      element.addEventListener(key.substring(2).toLowerCase(), value);
    } else {
      element.setAttribute(key, value);
    }
  });
  
  // Add children
  children.forEach(child => {
    if (typeof child === 'string') {
      element.appendChild(document.createTextNode(child));
    } else if (child instanceof Node) {
      element.appendChild(child);
    }
  });
  
  return element;
}

/**
 * Safe querySelector that handles errors
 */
function safeQuerySelector(element, selector) {
  try {
    return element.querySelector(selector);
  } catch (e) {
    console.error('Invalid selector:', selector, e);
    return null;
  }
}

/**
 * Safe querySelectorAll that handles errors
 */
function safeQuerySelectorAll(element, selector) {
  try {
    return element.querySelectorAll(selector);
  } catch (e) {
    console.error('Invalid selector:', selector, e);
    return [];
  }
}


  /* ============================================
   * MODULE: profileDiscovery.js
   * ============================================ */
/**
 * Profile section discovery module
 * Discovers and analyzes various LinkedIn profile sections
 */



/**
 * Main profile section discovery object
 */
const ProfileSectionDiscovery = {
  discoverSections() {
    const startTime = performance.now();
    
    const sections = {
      photo: this.hasPhoto(),
      backgroundBanner: this.hasCustomBanner(),
      location: this.hasLocation(),
      headline: this.getHeadlineInfo(),
      about: this.getAboutInfo(),
      experience: this.getExperienceInfo(),
      skills: this.getSkillsInfo(),
      education: this.getEducationInfo(),
      certifications: this.getCertificationsInfo(),
      projects: this.getProjectsInfo(),
      volunteer: this.getVolunteerInfo(),
      languages: this.getLanguagesInfo(),
      recommendations: this.getRecommendationsInfo(),
      honors: this.getHonorsInfo(),
      testScores: this.getTestScoresInfo(),
      topSkills: this.getTopSkillsInfo(),
      featured: this.getFeaturedInfo(),
      connections: this.getConnectionsInfo(),
      activity: this.getActivityInfo(),
      githubLink: this.hasGitHubLink(),
      openToWork: this.getOpenToWorkInfo()
    };
    
    sections.discoveryTime = Math.round(performance.now() - startTime) + 'ms';
    return sections;
  },
  
  hasPhoto() {
    const photoElement = document.querySelector(SELECTORS.PROFILE_PHOTO);
    return !!photoElement;
  },
  
  hasCustomBanner() {
    const banner = document.querySelector('.profile-background-image img') || 
                  document.querySelector('.pv-top-card__background-container img');
    return !!banner;
  },
  
  hasLocation() {
    const location = document.querySelector('.pv-text-details__left-panel .text-body-small:last-child') ||
                    document.querySelector('.pv-top-card--list-bullet li:first-child span') ||
                    document.querySelector('.pv-top-card__location span');
    return !!location && !!extractTextContent(location);
  },
  
  getHeadlineInfo() {
    const element = findElement([
      '.pv-text-details__left-panel .text-body-medium',
      '.pv-top-card-v2-section__headline',
      'div[data-field="headline"]'
    ]);
    
    if (!element) return { exists: false, charCount: 0, text: '' };
    
    const text = extractTextContent(element);
    return {
      exists: true,
      charCount: text.length,
      text: text,
      hasKeywords: /\b(senior|lead|expert|specialist|consultant|architect|manager|director|engineer|developer|designer)\b/i.test(text)
    };
  },
  
  getAboutInfo() {
    const section = document.querySelector(SELECTORS.ABOUT_SECTION);
    if (!section) return { exists: false, charCount: 0, text: '' };
    
    const contentDiv = section.querySelector('.pvs-list__outer-container span[aria-hidden="true"]') ||
                      section.querySelector('.pv-shared-text-with-see-more span[aria-hidden="true"]') ||
                      section.querySelector('.pv-about__summary-text span');
    
    if (!contentDiv) return { exists: false, charCount: 0, text: '' };
    
    const text = extractTextContent(contentDiv);
    return {
      exists: true,
      charCount: text.length,
      text: text,
      hasKeywords: /\b(passionate|experienced|skilled|proven|expert|results|achieve|deliver|leader)\b/i.test(text),
      wellFormatted: text.split('\n').length > 1 || text.split('.').length > 3
    };
  },
  
  getExperienceInfo() {
    const section = document.querySelector(SELECTORS.EXPERIENCE_SECTION);
    if (!section) return { exists: false, experiences: [] };
    
    // Check for "Show all X experiences" link
    const showAllLink = section.querySelector('.pvs-list__footer-wrapper a[href*="/details/experience"]');
    let totalCount = 0;
    
    if (showAllLink) {
      const text = extractTextContent(showAllLink);
      const match = text.match(/Show all (\d+) experiences/i);
      if (match) totalCount = parseInt(match[1]);
    }
    
    const experienceItems = safeQuerySelectorAll(section, '.pvs-list__paged-list-item');
    const experiences = [];
    
    experienceItems.forEach(item => {
      const titleElement = item.querySelector('.t-bold span[aria-hidden="true"]');
      const companyElement = item.querySelector('.t-normal:not(.t-black--light) span[aria-hidden="true"]');
      const descElement = item.querySelector('.pvs-list__outer-container > ul span[aria-hidden="true"]');
      
      if (titleElement) {
        const description = extractTextContent(descElement);
        experiences.push({
          title: extractTextContent(titleElement),
          company: extractTextContent(companyElement),
          charCount: description.length,
          hasMetrics: /\b(\d+%|\$\d+|\d+x|increased|decreased|improved|reduced|saved|generated)\b/i.test(description),
          hasQuantifiedAchievements: /\b\d+[%$kKmM]\b/.test(description)
        });
      }
    });
    
    return {
      exists: experiences.length > 0,
      count: totalCount || experiences.length,
      experiences: experiences,
      averageDescriptionLength: experiences.length > 0 
        ? Math.round(experiences.reduce((sum, exp) => sum + exp.charCount, 0) / experiences.length)
        : 0
    };
  },
  
  getSkillsInfo() {
    const section = document.querySelector(SELECTORS.SKILLS_SECTION);
    if (!section) return { exists: false, count: 0, skills: [] };
    
    // Check for "Show all X skills" link
    const showAllLink = section.querySelector('.pvs-list__footer-wrapper a[href*="/details/skills"]');
    let totalCount = 0;
    
    if (showAllLink) {
      const text = extractTextContent(showAllLink);
      const match = text.match(/Show all (\d+) skills/i);
      if (match) totalCount = parseInt(match[1]);
    }
    
    const skillElements = safeQuerySelectorAll(section, '.pvs-list__paged-list-item');
    const skills = [];
    
    skillElements.forEach(item => {
      const skillName = item.querySelector('.t-bold span[aria-hidden="true"]');
      if (skillName) {
        skills.push(extractTextContent(skillName));
      }
    });
    
    return {
      exists: skills.length > 0,
      count: totalCount || skills.length,
      skills: skills.slice(0, 10),
      hasEndorsements: section.querySelector('.pv-skill-category-entity__endorsement-count') !== null
    };
  },
  
  getEducationInfo() {
    const section = document.querySelector(SELECTORS.EDUCATION_SECTION);
    if (!section) return { exists: false, count: 0, education: [] };
    
    const educationItems = safeQuerySelectorAll(section, '.pvs-list__paged-list-item');
    const education = [];
    
    educationItems.forEach(item => {
      const schoolElement = item.querySelector('.t-bold span[aria-hidden="true"]');
      const degreeElement = item.querySelector('.t-normal:not(.t-black--light) span[aria-hidden="true"]');
      
      if (schoolElement) {
        education.push({
          school: extractTextContent(schoolElement),
          degree: extractTextContent(degreeElement)
        });
      }
    });
    
    return {
      exists: education.length > 0,
      count: education.length,
      education: education
    };
  },
  
  getCertificationsInfo() {
    const section = document.querySelector('#licenses_and_certifications')?.closest('section') ||
                   document.querySelector('section[data-section="certifications"]');
    if (!section) return { exists: false, count: 0 };
    
    const certItems = safeQuerySelectorAll(section, '.pvs-list__paged-list-item');
    return {
      exists: certItems.length > 0,
      count: certItems.length
    };
  },
  
  getProjectsInfo() {
    const section = document.querySelector('#projects')?.closest('section') ||
                   document.querySelector('section[data-section="projects"]');
    if (!section) return { exists: false, count: 0 };
    
    const projectItems = safeQuerySelectorAll(section, '.pvs-list__paged-list-item');
    return {
      exists: projectItems.length > 0,
      count: projectItems.length
    };
  },
  
  getVolunteerInfo() {
    const section = document.querySelector('#volunteering_experience')?.closest('section') ||
                   document.querySelector('section[data-section="volunteering"]');
    if (!section) return { exists: false, count: 0 };
    
    const volunteerItems = safeQuerySelectorAll(section, '.pvs-list__paged-list-item');
    return {
      exists: volunteerItems.length > 0,
      count: volunteerItems.length
    };
  },
  
  getLanguagesInfo() {
    const section = document.querySelector('#languages')?.closest('section') ||
                   document.querySelector('section[data-section="languages"]');
    if (!section) return { exists: false, count: 0 };
    
    const languageItems = safeQuerySelectorAll(section, '.pvs-list__paged-list-item');
    return {
      exists: languageItems.length > 0,
      count: languageItems.length
    };
  },
  
  getRecommendationsInfo() {
    const section = document.querySelector('#recommendations')?.closest('section') ||
                   document.querySelector('section[data-section="recommendations"]');
    if (!section) return { exists: false, received: 0, given: 0 };
    
    const tabs = safeQuerySelectorAll(section, '[role="tab"]');
    let received = 0, given = 0;
    
    tabs.forEach(tab => {
      const text = extractTextContent(tab);
      const receivedMatch = text.match(/Received \((\d+)\)/);
      const givenMatch = text.match(/Given \((\d+)\)/);
      
      if (receivedMatch) received = parseInt(receivedMatch[1]);
      if (givenMatch) given = parseInt(givenMatch[1]);
    });
    
    return {
      exists: received > 0 || given > 0,
      received: received,
      given: given
    };
  },
  
  getHonorsInfo() {
    const section = document.querySelector('#honors')?.closest('section') ||
                   document.querySelector('#honors_and_awards')?.closest('section');
    if (!section) return { exists: false, count: 0 };
    
    const honorItems = safeQuerySelectorAll(section, '.pvs-list__paged-list-item');
    return {
      exists: honorItems.length > 0,
      count: honorItems.length
    };
  },
  
  getTestScoresInfo() {
    const section = document.querySelector('#test_scores')?.closest('section') ||
                   document.querySelector('section[data-section="test-scores"]');
    if (!section) return { exists: false, count: 0 };
    
    const scoreItems = safeQuerySelectorAll(section, '.pvs-list__paged-list-item');
    return {
      exists: scoreItems.length > 0,
      count: scoreItems.length
    };
  },
  
  getTopSkillsInfo() {
    const section = document.querySelector('.pv-top-card--list') ||
                   document.querySelector('.pv-highlights-section');
    if (!section) return { exists: false, count: 0 };
    
    const skillButtons = safeQuerySelectorAll(section, 'button[aria-label*="skill"]');
    return {
      exists: skillButtons.length > 0,
      count: skillButtons.length
    };
  },
  
  getFeaturedInfo() {
    const section = document.querySelector('#featured')?.closest('section') ||
                   document.querySelector('section[data-section="featured"]');
    if (!section) return { exists: false, count: 0 };
    
    const featuredItems = safeQuerySelectorAll(section, '.pvs-list__paged-list-item');
    return {
      exists: featuredItems.length > 0,
      count: featuredItems.length
    };
  },
  
  getConnectionsInfo() {
    const connectionsElement = document.querySelector('.pv-top-card--list-bullet li span') ||
                              document.querySelector('a[href*="/connections"] span');
    
    if (!connectionsElement) return { exists: false, count: 0 };
    
    const text = extractTextContent(connectionsElement);
    const match = text.match(/(\d+[,\d]*)\+?\s*(connections|followers)/i);
    
    if (match) {
      const count = parseInt(match[1].replace(/,/g, ''));
      return {
        exists: true,
        count: count,
        is500Plus: text.includes('500+')
      };
    }
    
    return { exists: false, count: 0 };
  },
  
  getActivityInfo() {
    const section = document.querySelector('#content_collections')?.closest('section') ||
                   document.querySelector('section[data-section="posts"]');
    if (!section) return { exists: false, hasRecentActivity: false };
    
    const activityItems = safeQuerySelectorAll(section, '.feed-shared-update-v2');
    return {
      exists: activityItems.length > 0,
      hasRecentActivity: activityItems.length > 0,
      postCount: activityItems.length
    };
  },
  
  hasGitHubLink() {
    const contactInfo = document.querySelector('#top-card-text-details-contact-info') ||
                       document.querySelector('section.pv-contact-info');
    
    if (contactInfo) {
      const links = safeQuerySelectorAll(contactInfo, 'a[href*="github.com"]');
      return links.length > 0;
    }
    
    // Check featured section
    const featuredLinks = safeQuerySelectorAll(document, '#featured a[href*="github.com"]');
    return featuredLinks.length > 0;
  },
  
  getOpenToWorkInfo() {
    const badge = document.querySelector('.pv-member-badge--opentowork') ||
                 document.querySelector('[aria-label*="Open to work"]');
    return {
      exists: !!badge,
      isVisible: !!badge
    };
  }
};


  /* ============================================
   * MODULE: core/logger.js
   * ============================================ */
/**
 * Logger Module for ElevateLI
 * Provides structured logging with storage and export capabilities
 * This module will be concatenated into analyzer.js for Manifest V3 compatibility
 */

const Logger = {
  // Configuration
  MAX_LOGS: 1000, // Maximum number of log entries to keep
  LOG_KEY: 'elevateli_logs',
  PERFORMANCE_KEY: 'elevateli_performance',
  
  // Log levels
  levels: {
    DEBUG: 'DEBUG',
    INFO: 'INFO',
    WARN: 'WARN',
    ERROR: 'ERROR'
  },
  
  // Current log level (can be configured)
  currentLevel: 'INFO',
  
  // Module-specific log levels
  moduleLevels: {},
  
  // Performance tracking
  performanceMetrics: {},
  performanceEnabled: true,
  
  /**
   * Initialize logger
   */
  init() {
    // Set log level from storage if available
    chrome.storage.local.get(['logLevel', 'moduleLevels', 'performanceEnabled'], (data) => {
      if (data.logLevel && this.levels[data.logLevel]) {
        this.currentLevel = data.logLevel;
      }
      if (data.moduleLevels) {
        this.moduleLevels = data.moduleLevels;
      }
      if (data.performanceEnabled !== undefined) {
        this.performanceEnabled = data.performanceEnabled;
      }
    });
    
    console.log('[Logger] Initialized with level:', this.currentLevel);
  },
  
  /**
   * Set log level for specific module
   * @param {string} module - Module name
   * @param {string} level - Log level
   */
  setModuleLevel(module, level) {
    if (this.levels[level]) {
      this.moduleLevels[module] = level;
      chrome.storage.local.set({ moduleLevels: this.moduleLevels });
    }
  },
  
  /**
   * Core logging function
   * @param {string} level - Log level
   * @param {string} message - Log message
   * @param {Object} data - Additional data
   */
  async log(level, message, data = {}) {
    // Extract module from message if present
    const moduleMatch = message.match(/^\[([^\]]+)\]/);
    const module = moduleMatch ? moduleMatch[1] : 'General';
    
    // Check if we should log this level
    if (!this.shouldLog(level, module)) return;
    
    const entry = {
      timestamp: Date.now(),
      level,
      module,
      message,
      data,
      url: window.location.href,
      profileId: this.getProfileId()
    };
    
    // Log to console
    const consoleMethod = level === 'ERROR' ? 'error' : level === 'WARN' ? 'warn' : 'log';
    console[consoleMethod](`[${level}] ${message}`, data);
    
    // Store in Chrome storage
    try {
      const stored = await chrome.storage.local.get(this.LOG_KEY);
      let logs = stored[this.LOG_KEY] || [];
      
      // Add new entry
      logs.push(entry);
      
      // Keep only recent logs
      if (logs.length > this.MAX_LOGS) {
        logs = logs.slice(-this.MAX_LOGS);
      }
      
      await chrome.storage.local.set({ [this.LOG_KEY]: logs });
    } catch (error) {
      console.error('[Logger] Failed to store log:', error);
    }
  },
  
  /**
   * Convenience methods for different log levels
   */
  debug(message, data) {
    return this.log(this.levels.DEBUG, message, data);
  },
  
  info(message, data) {
    return this.log(this.levels.INFO, message, data);
  },
  
  warn(message, data) {
    return this.log(this.levels.WARN, message, data);
  },
  
  error(message, data) {
    return this.log(this.levels.ERROR, message, data);
  },
  
  /**
   * Check if we should log at this level
   * @param {string} level - Log level to check
   * @param {string} module - Module name
   * @returns {boolean}
   */
  shouldLog(level, module = 'General') {
    const levelOrder = ['DEBUG', 'INFO', 'WARN', 'ERROR'];
    
    // Check module-specific level first
    const moduleLevel = this.moduleLevels[module] || this.currentLevel;
    const currentIndex = levelOrder.indexOf(moduleLevel);
    const checkIndex = levelOrder.indexOf(level);
    
    return checkIndex >= currentIndex;
  },
  
  /**
   * Start performance measurement
   * @param {string} operation - Operation name
   * @returns {string} Measurement ID
   */
  startPerformance(operation) {
    if (!this.performanceEnabled) return null;
    
    const id = `${operation}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    this.performanceMetrics[id] = {
      operation,
      startTime: performance.now(),
      startMemory: performance.memory ? performance.memory.usedJSHeapSize : 0
    };
    
    return id;
  },
  
  /**
   * End performance measurement
   * @param {string} id - Measurement ID
   * @param {Object} metadata - Additional metadata
   */
  async endPerformance(id, metadata = {}) {
    if (!this.performanceEnabled || !id || !this.performanceMetrics[id]) return;
    
    const metric = this.performanceMetrics[id];
    const duration = performance.now() - metric.startTime;
    const endMemory = performance.memory ? performance.memory.usedJSHeapSize : 0;
    const memoryDelta = endMemory - metric.startMemory;
    
    const performanceData = {
      operation: metric.operation,
      duration: Math.round(duration * 100) / 100,
      memoryDelta: Math.round(memoryDelta / 1024),
      timestamp: Date.now(),
      ...metadata
    };
    
    // Log performance data
    this.debug(`[Performance] ${metric.operation} completed`, performanceData);
    
    // Store performance metrics
    try {
      const stored = await chrome.storage.local.get(this.PERFORMANCE_KEY);
      let metrics = stored[this.PERFORMANCE_KEY] || [];
      
      metrics.push(performanceData);
      
      // Keep only recent metrics (last 500)
      if (metrics.length > 500) {
        metrics = metrics.slice(-500);
      }
      
      await chrome.storage.local.set({ [this.PERFORMANCE_KEY]: metrics });
    } catch (error) {
      console.error('[Logger] Failed to store performance metric:', error);
    }
    
    // Clean up
    delete this.performanceMetrics[id];
    
    return performanceData;
  },
  
  /**
   * Get current profile ID from URL
   * @returns {string|null}
   */
  getProfileId() {
    const match = window.location.pathname.match(/\/in\/([^\/]+)/);
    return match ? match[1] : null;
  },
  
  /**
   * Export logs for debugging
   * @param {Object} options - Export options
   * @returns {Promise<Array>} Log entries
   */
  async export(options = {}) {
    const stored = await chrome.storage.local.get(this.LOG_KEY);
    let logs = stored[this.LOG_KEY] || [];
    
    // Filter by options
    if (options.level) {
      logs = logs.filter(log => log.level === options.level);
    }
    
    if (options.profileId) {
      logs = logs.filter(log => log.profileId === options.profileId);
    }
    
    if (options.since) {
      logs = logs.filter(log => log.timestamp >= options.since);
    }
    
    // Format for export
    return logs.map(log => ({
      ...log,
      time: new Date(log.timestamp).toISOString()
    }));
  },
  
  /**
   * Clear all logs
   */
  async clear() {
    await chrome.storage.local.remove(this.LOG_KEY);
    console.log('[Logger] All logs cleared');
  },
  
  /**
   * Get logs summary
   * @returns {Promise<Object>} Summary statistics
   */
  async getSummary() {
    const stored = await chrome.storage.local.get(this.LOG_KEY);
    const logs = stored[this.LOG_KEY] || [];
    
    const summary = {
      total: logs.length,
      byLevel: {},
      byModule: {},
      oldestEntry: null,
      newestEntry: null
    };
    
    // Count by level
    Object.values(this.levels).forEach(level => {
      summary.byLevel[level] = logs.filter(log => log.level === level).length;
    });
    
    // Count by module
    logs.forEach(log => {
      const module = log.module || 'General';
      summary.byModule[module] = (summary.byModule[module] || 0) + 1;
    });
    
    // Get time range
    if (logs.length > 0) {
      summary.oldestEntry = new Date(logs[0].timestamp).toISOString();
      summary.newestEntry = new Date(logs[logs.length - 1].timestamp).toISOString();
    }
    
    return summary;
  },
  
  /**
   * Get performance summary
   * @returns {Promise<Object>} Performance statistics
   */
  async getPerformanceSummary() {
    const stored = await chrome.storage.local.get(this.PERFORMANCE_KEY);
    const metrics = stored[this.PERFORMANCE_KEY] || [];
    
    if (metrics.length === 0) {
      return { message: 'No performance metrics available' };
    }
    
    // Group by operation
    const byOperation = {};
    metrics.forEach(metric => {
      if (!byOperation[metric.operation]) {
        byOperation[metric.operation] = {
          count: 0,
          totalDuration: 0,
          avgDuration: 0,
          minDuration: Infinity,
          maxDuration: 0
        };
      }
      
      const op = byOperation[metric.operation];
      op.count++;
      op.totalDuration += metric.duration;
      op.minDuration = Math.min(op.minDuration, metric.duration);
      op.maxDuration = Math.max(op.maxDuration, metric.duration);
    });
    
    // Calculate averages
    Object.values(byOperation).forEach(op => {
      op.avgDuration = Math.round(op.totalDuration / op.count * 100) / 100;
    });
    
    return {
      totalMetrics: metrics.length,
      operations: byOperation,
      timeRange: {
        start: new Date(metrics[0].timestamp).toISOString(),
        end: new Date(metrics[metrics.length - 1].timestamp).toISOString()
      }
    };
  }
};

// Initialize logger when module loads
if (typeof chrome !== 'undefined' && chrome.storage) {
  Logger.init();
}


  /* ============================================
   * MODULE: core/cache-manager.js
   * ============================================ */
/**
 * Cache Manager Module for ElevateLI
 * Handles content-based caching with configurable expiration
 * This module will be concatenated into analyzer.js for Manifest V3 compatibility
 */

class CacheManager {
  constructor(cacheDurationDays = 7) {
    this.cacheDurationDays = cacheDurationDays;
    this.AI_CACHE_PREFIX = 'aiCache_';
    this.COMPLETENESS_CACHE_PREFIX = 'completeness_';
  }
  
  /**
   * Generate content hash including profile data and settings
   * @param {Object} profileData - Extracted profile data
   * @param {Object} settings - Analysis settings (targetRole, seniorityLevel, etc)
   * @returns {string} Content hash
   */
  generateHash(profileData, settings) {
    // Include all data points that affect analysis
    const dataPoints = [
      // Profile content
      profileData.photo ? 1 : 0,
      profileData.headline?.charCount || 0,
      profileData.about?.charCount || 0,
      profileData.experience?.count || 0,
      profileData.skills?.count || 0,
      profileData.education?.count || 0,
      profileData.recommendations?.count || 0,
      profileData.certifications?.count || 0,
      profileData.featured ? 1 : 0,
      profileData.projects?.count || 0,
      profileData.connections || 0,
      // Settings that affect analysis
      settings.targetRole || 'none',
      settings.seniorityLevel || 'none',
      settings.customInstructions ? 'custom' : 'default'
    ];
    
    return dataPoints.join('-');
  }
  
  /**
   * Get cached data for a profile
   * @param {string} profileId - LinkedIn profile ID
   * @returns {Promise<Object|null>} Cached data or null
   */
  async get(profileId) {
    return new Promise((resolve) => {
      const cacheKey = `cache_${profileId}`;
      
      chrome.storage.local.get([cacheKey], (data) => {
        if (chrome.runtime.lastError) {
          Logger.error('[CacheManager] Error reading cache:', chrome.runtime.lastError);
          resolve(null);
          return;
        }
        
        const cachedData = data[cacheKey];
        if (!cachedData) {
          Logger.info('[CacheManager] No cache found for profile:', profileId);
          resolve(null);
          return;
        }
        
        // Check if cache is expired
        const cacheAge = Date.now() - new Date(cachedData.timestamp).getTime();
        const maxAge = this.cacheDurationDays * 24 * 60 * 60 * 1000;
        
        if (cacheAge > maxAge) {
          Logger.info('[CacheManager] Cache expired for profile:', profileId);
          resolve(null);
          return;
        }
        
        Logger.info('[CacheManager] Found valid cache for profile:', profileId);
        resolve(cachedData);
      });
    });
  }
  
  /**
   * Save data to cache
   * @param {string} profileId - LinkedIn profile ID
   * @param {Object} analysisData - Analysis results to cache
   * @param {Object} extractedData - Raw extracted data
   * @returns {Promise<boolean>} Success status
   */
  async save(profileId, analysisData, extractedData) {
    return new Promise((resolve) => {
      const cacheKey = `cache_${profileId}`;
      
      const cacheData = {
        ...analysisData,
        extractedData: extractedData,
        timestamp: new Date().toISOString(),
        version: '1.0'
      };
      
      const storageData = {
        [cacheKey]: cacheData
      };
      
      chrome.storage.local.set(storageData, () => {
        if (chrome.runtime.lastError) {
          Logger.error('[CacheManager] Error saving cache:', chrome.runtime.lastError);
          resolve(false);
        } else {
          Logger.info('[CacheManager] Saved cache for profile:', profileId);
          resolve(true);
        }
      });
    });
  }
  
  /**
   * Check cache and return data if valid (content unchanged)
   * @param {string} profileId - LinkedIn profile ID
   * @param {Object} currentSettings - Current analysis settings
   * @returns {Object|null} Cached data or null
   */
  async checkAndReturn(profileId, currentSettings) {
    if (!profileId) {
      Logger.info('[CacheManager] No profile ID provided');
      return null;
    }
    
    const cachedData = await this.get(profileId);
    if (!cachedData) return null;
    
    // For now, just return cached data if it exists and isn't expired
    // In future, could compare content hash to detect changes
    return cachedData;
  }
  
  /**
   * Clear cache for a specific profile
   * @param {string} profileId - LinkedIn profile ID
   * @returns {Promise<boolean>} Success status
   */
  async clear(profileId) {
    return new Promise((resolve) => {
      const cacheKey = `cache_${profileId}`;
      
      chrome.storage.local.remove([cacheKey], () => {
        if (chrome.runtime.lastError) {
          Logger.error('[CacheManager] Error clearing cache:', chrome.runtime.lastError);
          resolve(false);
        } else {
          Logger.info('[CacheManager] Cleared cache for profile:', profileId);
          resolve(true);
        }
      });
    });
  }
  
  /**
   * Clear all caches
   * @returns {Promise<boolean>} Success status
   */
  async clearAll() {
    return new Promise((resolve) => {
      chrome.storage.local.get(null, (data) => {
        const cacheKeys = Object.keys(data).filter(key => key.startsWith('cache_'));
        
        if (cacheKeys.length === 0) {
          Logger.info('[CacheManager] No caches to clear');
          resolve(true);
          return;
        }
        
        chrome.storage.local.remove(cacheKeys, () => {
          if (chrome.runtime.lastError) {
            Logger.error('[CacheManager] Error clearing all caches:', chrome.runtime.lastError);
            resolve(false);
          } else {
            Logger.info('[CacheManager] Cleared all caches:', cacheKeys.length);
            resolve(true);
          }
        });
      });
    });
  }
}


  /* ============================================
   * MODULE: extractors/base-extractor.js
   * ============================================ */
/**
 * Base Extractor Module for ElevateLI
 * Provides common functionality for all section extractors
 * This module will be concatenated into analyzer.js for Manifest V3 compatibility
 */

const BaseExtractor = {
  /**
   * Common utility to extract text content safely
   * @param {Element} element - DOM element
   * @returns {string} Extracted text
   */
  extractTextContent(element) {
    if (!element) return '';
    
    // Check for aria-hidden="true" spans first (LinkedIn's actual text)
    const ariaHiddenSpan = element.querySelector('span[aria-hidden="true"]');
    if (ariaHiddenSpan) {
      return ariaHiddenSpan.textContent?.trim() || '';
    }
    
    // Fallback to regular text content
    return element.textContent?.trim() || '';
  },
  
  /**
   * Wait for element with timeout
   * @param {string} selector - CSS selector
   * @param {number} timeout - Max wait time in ms
   * @returns {Promise<Element|null>}
   */
  async waitForElement(selector, timeout = 3000) {
    const startTime = Date.now();
    
    while (Date.now() - startTime < timeout) {
      const element = document.querySelector(selector);
      if (element) return element;
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    
    return null;
  },
  
  /**
   * Click "Show all" button if present
   * @param {Element} section - Section element
   * @param {string} buttonSelector - Button selector
   * @returns {Promise<boolean>} Success status
   */
  async expandSection(section, buttonSelector) {
    if (!section) return false;
    
    const showAllButton = section.querySelector(buttonSelector);
    if (!showAllButton || showAllButton.disabled) return false;
    
    console.log(`[Extractor] Clicking "Show all" button...`);
    showAllButton.click();
    
    // Wait for content to load
    await new Promise(resolve => setTimeout(resolve, 1500));
    
    return true;
  },
  
  /**
   * Find section by multiple strategies
   * @param {Array<string>} selectors - Array of selectors to try
   * @param {string} headingText - Text to search in headings
   * @returns {Element|null}
   */
  findSection(selectors, headingText) {
    Logger.info(`[BaseExtractor] findSection called for "${headingText}" with ${selectors.length} selectors`);
    
    // Filter out invalid selectors (jQuery-specific :contains())
    const validSelectors = selectors.filter(sel => !sel.includes(':contains('));
    
    // Try valid selectors
    for (const selector of validSelectors) {
      try {
        const element = document.querySelector(selector);
        if (element) {
          // Skip if this is just an anchor element (we'll handle it in anchor-based search)
          if (element.classList.contains('pv-profile-card__anchor')) {
            Logger.info(`[BaseExtractor] Skipping anchor element for selector: ${selector}`);
            continue;
          }
          return element;
        }
      } catch (e) {
        // Log selector errors at debug level
        if (typeof Logger !== 'undefined') {
          Logger.info(`[BaseExtractor] Selector error: ${selector}`, e.message);
        }
      }
    }
    
    // Try anchor-based search (LinkedIn's pattern)
    if (headingText) {
      // Try different ID patterns based on section name
      const sectionName = headingText.toLowerCase();
      const possibleIds = [
        sectionName.replace(/\s+/g, '-'),  // "work experience" → "work-experience"
        sectionName.replace(/\s+/g, ''),   // "work experience" → "workexperience"
        sectionName.split(' ')[0],         // "work experience" → "work"
        sectionName                        // "skills" → "skills"
      ];
      
      Logger.info(`[BaseExtractor] Trying anchor pattern for "${headingText}" with IDs:`, possibleIds);
      
      for (const id of possibleIds) {
        const anchor = document.querySelector(`div#${id}.pv-profile-card__anchor`);
        if (anchor) {
          Logger.info(`[BaseExtractor] Found anchor with ID: #${id}`);
          
          // For skills and recommendations, skip parent section and check siblings
          if (sectionName !== 'skills' && sectionName !== 'recommendations') {
            // First try parent section for other sections
            const section = anchor.closest('section');
            if (section) {
              Logger.info(`[BaseExtractor] Found section via anchor parent: #${id}`);
              return section;
            }
          } else {
            Logger.info(`[BaseExtractor] Skipping parent section for ${sectionName}, checking siblings directly`);
          }
          
          // Try siblings after anchor
          let sibling = anchor.nextElementSibling;
          let siblingCount = 0;
          while (sibling && siblingCount < 5) {
            Logger.info(`[BaseExtractor] Checking sibling ${siblingCount}, tag: ${sibling.tagName}, classes: ${sibling.className}`);
            
            // For skills, need BOTH skill items AND show all link (not just header)
            if (sectionName === 'skills') {
              const skillLinks = sibling.querySelectorAll('[data-field="skill_card_skill_topic"]');
              const hasShowAllSkills = sibling.querySelector('a[href*="/details/skills"]');
              
              // Only return if we have actual skill items (not just the header with show all)
              if (skillLinks.length > 0) {
                Logger.info(`[BaseExtractor] Found skills section with ${skillLinks.length} skills in sibling ${siblingCount}`);
                return sibling;
              } else if (hasShowAllSkills) {
                // Log but don't return - this might just be the header
                Logger.info(`[BaseExtractor] Sibling ${siblingCount} has show all link but no skills, continuing search`);
              }
            }
            
            // Check if sibling contains meaningful content (lists or items)
            const hasLists = sibling.querySelector('ul, .pvs-list');
            const hasItems = sibling.querySelectorAll('li').length > 0;
            
            if (hasLists || hasItems) {
              // Additional check: make sure it's not just an empty container
              const textContent = sibling.textContent.trim();
              if (textContent.length > 20) { // Has some actual content
                Logger.info(`[BaseExtractor] Found section via anchor sibling: #${id}`);
                return sibling;
              }
            }
            
            sibling = sibling.nextElementSibling;
            siblingCount++;
          }
        }
      }
    }
    
    // Enhanced heading text search
    if (headingText) {
      const headings = document.querySelectorAll('h2');
      for (const heading of headings) {
        // Check for exact match or contains
        if (heading.textContent?.trim() === headingText || 
            heading.textContent?.includes(headingText)) {
          // Try multiple parent containers
          const section = heading.closest('section') || 
                         heading.closest('div[data-view-name="profile-card"]') ||
                         heading.closest('div[class*="profile-card"]');
          if (section) return section;
        }
      }
    }
    
    return null;
  },
  
  /**
   * Count items in a section
   * @param {Element} section - Section element
   * @param {string} itemSelector - Item selector
   * @returns {number}
   */
  countItems(section, itemSelector) {
    if (!section) return 0;
    return section.querySelectorAll(itemSelector).length;
  },
  
  /**
   * Chunk large text for AI processing
   * @param {string} text - Text to chunk
   * @param {number} maxSize - Max chunk size
   * @returns {Array<string>}
   */
  chunkText(text, maxSize = 1000) {
    if (!text || text.length <= maxSize) return [text];
    
    const chunks = [];
    const sentences = text.match(/[^.!?]+[.!?]+/g) || [text];
    let currentChunk = '';
    
    for (const sentence of sentences) {
      if ((currentChunk + sentence).length > maxSize && currentChunk) {
        chunks.push(currentChunk.trim());
        currentChunk = sentence;
      } else {
        currentChunk += sentence;
      }
    }
    
    if (currentChunk) {
      chunks.push(currentChunk.trim());
    }
    
    return chunks;
  },
  
  /**
   * Extract count from "Show all" button without clicking
   * @param {Element} section - Section element
   * @param {string} sectionName - Name of the section (e.g., "skills", "experience")
   * @returns {Object} Count information
   */
  extractShowAllInfo(section, sectionName) {
    if (!section) return { totalCount: 0, showAllUrl: null };
    
    // Common patterns for "Show all" buttons/links
    const showAllSelectors = [
      // Primary: Look for details links first (most reliable)
      `a[href*="/details/${sectionName}"]`,
      `a[href*="/details/${sectionName}/"]`,
      // Secondary: aria-label patterns
      `[aria-label*="Show all"][aria-label*="${sectionName}"]`,
      `[aria-label*="Show all ${sectionName}"]`,
      'button[aria-label*="Show all"]',
      'a[aria-label*="Show all"]',
      // LinkedIn's specific pattern
      '.pvs-list__footer-wrapper a',
      `a[id*="Show-all"][id*="${sectionName}"]`,
      'a[id*="navigation-index-Show-all"]'
    ];
    
    let totalCount = 0;
    let showAllUrl = null;
    
    for (const selector of showAllSelectors) {
      try {
        const element = section.querySelector(selector);
        if (element) {
          // Log what we found
          const href = element.getAttribute('href') || '';
          Logger.info(`[BaseExtractor] Found element with selector "${selector}", href: "${href}"`);
          
          // Extract count from aria-label or text content
          const ariaLabel = element.getAttribute('aria-label') || '';
          const textContent = element.textContent || '';
          const combinedText = ariaLabel + ' ' + textContent;
          
          // Try to match the number with multiple patterns
          const patterns = [
            /Show\s+all\s+(\d+)/i,
            /Show\s+all\s+\((\d+)\)/i,
            new RegExp(`(\\d+)\\s+${sectionName}`, 'i'),
            new RegExp(`${sectionName}\\s*\\((\\d+)\\)`, 'i'),
            /(\d+)\s+items?/i
          ];
          
          for (const pattern of patterns) {
            const match = combinedText.match(pattern);
            if (match) {
              totalCount = parseInt(match[1]);
              Logger.info(`[BaseExtractor] Found count ${totalCount} in show all: "${combinedText.substring(0, 50)}..."`);
              break;
            }
          }
          
          // Extract URL if it's a link
          if (element.tagName === 'A' && element.href) {
            showAllUrl = element.href;
          }
          
          if (totalCount > 0) break;
        }
      } catch (e) {
        // Continue with next selector
      }
    }
    
    // If no count found, look for text patterns
    if (totalCount === 0) {
      Logger.info(`[BaseExtractor] No count found in show all buttons, searching text for ${sectionName}`);
      const textElements = section.querySelectorAll('span, div, a');
      for (const el of textElements) {
        const text = el.textContent || '';
        if (text.length > 200) continue; // Skip long text blocks
        
        const patterns = [
          new RegExp(`(\\d+)\\s+${sectionName}`, 'i'),
          new RegExp(`${sectionName}\\s*\\((\\d+)\\)`, 'i'),
          new RegExp(`Show\\s+all\\s+(\\d+)`, 'i'),
          new RegExp(`View\\s+all\\s+(\\d+)`, 'i'),
          new RegExp(`(\\d+)\\s+total`, 'i')
        ];
        
        for (const pattern of patterns) {
          const match = text.match(pattern);
          if (match) {
            totalCount = parseInt(match[1]);
            Logger.info(`[BaseExtractor] Found count ${totalCount} in text: "${text.substring(0, 50)}..."`);
            break;
          }
        }
        if (totalCount > 0) break;
      }
    }
    
    return { totalCount, showAllUrl };
  },
  
  /**
   * Check if section has meaningful content
   * @param {Object} data - Extracted data
   * @returns {boolean}
   */
  hasContent(data) {
    if (!data || !data.exists) return false;
    
    // Check various indicators of content
    if (data.count && data.count > 0) return true;
    if (data.charCount && data.charCount > 0) return true;
    if (data.items && data.items.length > 0) return true;
    if (data.text && data.text.length > 0) return true;
    
    return false;
  },
  
  /**
   * Log extraction timing
   * @param {string} section - Section name
   * @param {number} startTime - Start timestamp
   * @param {Object} metadata - Additional metadata
   */
  logTiming(section, startTime, metadata = {}) {
    const duration = Date.now() - startTime;
    Logger.info(`[${section}Extractor] Extraction completed in ${duration}ms`, {
      duration,
      ...metadata
    });
  }
};


  /* ============================================
   * MODULE: extractors/photo.js
   * ============================================ */
/**
 * Photo Extractor Module for ElevateLI
 * Handles detection of LinkedIn profile photo
 * This module will be concatenated into analyzer.js for Manifest V3 compatibility
 */

const PhotoExtractor = {
  name: 'photo',
  
  selectors: [
    '.pv-top-card-profile-picture img',
    '.profile-photo-edit__preview',
    '.pv-top-card__photo img',
    '.pv-top-card-profile-picture__image',
    'img[class*="profile-photo"]',
    'img[class*="pv-top-card"][class*="photo"]'
  ],
  
  /**
   * Quick scan for profile photo existence
   * @returns {Object} Scan results
   */
  async scan() {
    const startTime = Date.now();
    
    let exists = false;
    let photoUrl = null;
    
    // Try each selector
    for (const selector of this.selectors) {
      const photoElement = document.querySelector(selector);
      if (photoElement) {
        exists = true;
        photoUrl = photoElement.src || photoElement.getAttribute('src');
        Logger.debug(`[PhotoExtractor] Found photo with selector: ${selector}`);
        break;
      }
    }
    
    // If not found with selectors, try finding by attributes
    if (!exists) {
      const allImages = document.querySelectorAll('img');
      for (const img of allImages) {
        const alt = img.alt || '';
        const className = img.className || '';
        if (alt.toLowerCase().includes('profile photo') || 
            alt.includes('profile picture') ||
            className.includes('profile-photo')) {
          exists = true;
          photoUrl = img.src;
          Logger.debug('[PhotoExtractor] Found photo by attribute search');
          break;
        }
      }
    }
    
    Logger.info(`[PhotoExtractor] Scan completed in ${Date.now() - startTime}ms`, {
      exists,
      hasUrl: !!photoUrl
    });
    
    return {
      exists,
      photoUrl
    };
  },
  
  /**
   * Extract photo data for completeness scoring
   * @returns {Object} Photo data
   */
  async extract() {
    const scanResult = await this.scan();
    
    return {
      exists: scanResult.exists,
      hasPhoto: scanResult.exists,
      photoUrl: scanResult.photoUrl
    };
  },
  
  /**
   * Deep extraction is same as basic for photo
   * @returns {Object} Photo data
   */
  async extractDeep() {
    return this.extract();
  }
};


  /* ============================================
   * MODULE: extractors/headline.js
   * ============================================ */
/**
 * Headline Extractor Module for ElevateLI
 * Handles extraction of LinkedIn profile headline
 * This module will be concatenated into analyzer.js for Manifest V3 compatibility
 */

const HeadlineExtractor = {
  name: 'headline',
  
  /**
   * Quick scan for headline existence
   * @returns {Object} Scan results
   */
  async scan() {
    const startTime = Date.now();
    
    const selectors = [
      // New selector based on actual LinkedIn HTML
      '.text-body-medium[data-generated-suggestion-target]',
      // Keep old selector as fallback
      '.pv-text-details__left-panel .text-body-medium',
      // Additional fallback for profile header
      'section[data-member-id] .text-body-medium'
    ];
    
    let element = null;
    let usedSelector = null;
    
    for (const selector of selectors) {
      element = document.querySelector(selector);
      if (element) {
        usedSelector = selector;
        break;
      }
    }
    
    const exists = !!element;
    
    BaseExtractor.logTiming('Headline scan', startTime);
    Logger.debug(`[HeadlineExtractor] Scan result: exists=${exists}, selector=${usedSelector}`);
    
    return {
      exists,
      selector: usedSelector,
      element
    };
  },
  
  /**
   * Extract headline for completeness scoring
   * @returns {Object} Basic headline data
   */
  async extract() {
    const startTime = Date.now();
    const scanResult = await this.scan();
    
    if (!scanResult.exists) {
      return {
        exists: false,
        charCount: 0,
        text: ''
      };
    }
    
    const element = scanResult.element || document.querySelector(scanResult.selector);
    const text = BaseExtractor.extractTextContent(element);
    
    const result = {
      exists: true,
      charCount: text.length,
      text: text,
      // Quick quality checks for completeness
      hasKeywords: this.checkKeywords(text),
      isGeneric: this.checkIfGeneric(text),
      hasPipe: text.includes('|'),
      hasAt: text.includes('@')
    };
    
    BaseExtractor.logTiming('Headline extract', startTime);
    return result;
  },
  
  /**
   * Deep extraction for AI analysis
   * @returns {Object} Detailed headline data
   */
  async extractDeep() {
    const basicData = await this.extract();
    
    if (!basicData.exists) return basicData;
    
    // Add deep analysis data
    return {
      ...basicData,
      // Linguistic analysis
      wordCount: basicData.text.split(/\s+/).length,
      keywords: this.extractKeywords(basicData.text),
      sentiment: this.analyzeSentiment(basicData.text),
      
      // Structure analysis  
      parts: this.parseHeadlineParts(basicData.text),
      hasTitle: this.containsJobTitle(basicData.text),
      hasCompany: this.containsCompany(basicData.text),
      hasValue: this.containsValueProp(basicData.text),
      
      // Optimization suggestions
      optimizationPotential: this.calculateOptimizationPotential(basicData)
    };
  },
  
  /**
   * Check for important keywords
   * @param {string} text - Headline text
   * @returns {boolean}
   */
  checkKeywords(text) {
    const keywords = [
      'senior', 'lead', 'principal', 'director', 'manager',
      'engineer', 'developer', 'designer', 'analyst', 'consultant',
      'expert', 'specialist', 'architect', 'strategist'
    ];
    
    const lowerText = text.toLowerCase();
    return keywords.some(keyword => lowerText.includes(keyword));
  },
  
  /**
   * Check if headline is too generic
   * @param {string} text - Headline text
   * @returns {boolean}
   */
  checkIfGeneric(text) {
    const genericPhrases = [
      'looking for opportunities',
      'seeking new role',
      'open to work',
      'unemployed',
      'student at'
    ];
    
    const lowerText = text.toLowerCase();
    return genericPhrases.some(phrase => lowerText.includes(phrase));
  },
  
  /**
   * Extract keywords for analysis
   * @param {string} text - Headline text
   * @returns {Array<string>}
   */
  extractKeywords(text) {
    // Remove common words and extract meaningful terms
    const stopWords = ['the', 'a', 'an', 'and', 'or', 'but', 'in', 'at', 'to', 'for'];
    const words = text.toLowerCase().split(/\W+/);
    
    return words
      .filter(word => word.length > 2 && !stopWords.includes(word))
      .filter((word, index, self) => self.indexOf(word) === index);
  },
  
  /**
   * Simple sentiment analysis
   * @param {string} text - Headline text
   * @returns {string}
   */
  analyzeSentiment(text) {
    const positive = ['passionate', 'expert', 'leader', 'innovative', 'experienced'];
    const negative = ['seeking', 'looking', 'unemployed', 'former'];
    
    const lowerText = text.toLowerCase();
    let score = 0;
    
    positive.forEach(word => {
      if (lowerText.includes(word)) score++;
    });
    
    negative.forEach(word => {
      if (lowerText.includes(word)) score--;
    });
    
    return score > 0 ? 'positive' : score < 0 ? 'negative' : 'neutral';
  },
  
  /**
   * Parse headline into logical parts
   * @param {string} text - Headline text
   * @returns {Object}
   */
  parseHeadlineParts(text) {
    const parts = {
      title: '',
      company: '',
      value: '',
      other: []
    };
    
    // Split by common separators
    const segments = text.split(/[|,@•]/);
    
    segments.forEach(segment => {
      const trimmed = segment.trim();
      if (this.containsJobTitle(trimmed)) {
        parts.title = trimmed;
      } else if (this.containsCompany(trimmed)) {
        parts.company = trimmed;
      } else if (this.containsValueProp(trimmed)) {
        parts.value = trimmed;
      } else if (trimmed) {
        parts.other.push(trimmed);
      }
    });
    
    return parts;
  },
  
  /**
   * Check if text contains job title
   * @param {string} text - Text to check
   * @returns {boolean}
   */
  containsJobTitle(text) {
    const titleKeywords = [
      'manager', 'director', 'engineer', 'developer',
      'designer', 'analyst', 'consultant', 'specialist',
      'lead', 'head', 'vp', 'president', 'chief'
    ];
    
    const lowerText = text.toLowerCase();
    return titleKeywords.some(keyword => lowerText.includes(keyword));
  },
  
  /**
   * Check if text contains company reference
   * @param {string} text - Text to check
   * @returns {boolean}
   */
  containsCompany(text) {
    return text.includes('@') || 
           text.toLowerCase().includes(' at ') ||
           /\b(Inc|LLC|Ltd|Corp|Company)\b/i.test(text);
  },
  
  /**
   * Check if text contains value proposition
   * @param {string} text - Text to check
   * @returns {boolean}
   */
  containsValueProp(text) {
    const valueKeywords = [
      'helping', 'building', 'creating', 'driving',
      'transforming', 'leading', 'delivering', 'solving'
    ];
    
    const lowerText = text.toLowerCase();
    return valueKeywords.some(keyword => lowerText.includes(keyword));
  },
  
  /**
   * Calculate optimization potential
   * @param {Object} data - Headline data
   * @returns {number} Score 0-100
   */
  calculateOptimizationPotential(data) {
    let score = 100;
    
    // Deduct points for issues
    if (data.charCount < 30) score -= 20;
    if (data.charCount > 220) score -= 10;
    if (!data.hasKeywords) score -= 15;
    if (data.isGeneric) score -= 25;
    if (!data.hasPipe && !data.hasAt) score -= 10;
    if (data.wordCount < 3) score -= 20;
    
    return Math.max(0, score);
  }
};


  /* ============================================
   * MODULE: extractors/about.js
   * ============================================ */
/**
 * About Extractor Module for ElevateLI
 * Handles extraction of LinkedIn profile About section
 * This module will be concatenated into analyzer.js for Manifest V3 compatibility
 */

const AboutExtractor = {
  name: 'about',
  
  // Multiple selectors to handle LinkedIn's changing DOM
  selectors: [
    'section[data-section="summary"]',
    'section:has(div#about)',
    'section:has(h2:contains("About"))',
    'div[data-view-name="profile-card"]:has(div#about)',
    'section.pv-about-section',
    'section.pv-profile-section:has(.pv-about__summary-text)'
  ],
  
  // Selectors for the actual text content
  textSelectors: [
    '[class*="inline-show-more-text"] span[aria-hidden="true"]',
    '.pv-about__summary-text span[aria-hidden="true"]',
    '.pv-shared-text-with-see-more span[aria-hidden="true"]',
    '[class*="full-width"] span[aria-hidden="true"]',
    '.pvs-list__outer-container span[aria-hidden="true"]'
  ],
  
  /**
   * Quick scan for about section existence
   * @returns {Object} Scan results
   */
  async scan() {
    const startTime = Date.now();
    
    const section = BaseExtractor.findSection(this.selectors, 'About');
    const exists = !!section;
    
    let hasShowMore = false;
    if (exists) {
      // Check for "Show more" button
      const showMoreSelectors = [
        'button[aria-label*="more about"]',
        'button[aria-label*="Show more"]',
        'a[aria-label*="see more"]',
        'button.inline-show-more-text__button',
        '[class*="inline-show-more-text"] button'
      ];
      
      hasShowMore = showMoreSelectors.some(selector => 
        section.querySelector(selector) !== null
      );
    }
    
    Logger.debug(`[AboutExtractor] Scan completed in ${Date.now() - startTime}ms`, {
      exists,
      hasShowMore
    });
    
    return {
      exists,
      hasShowMore,
      selector: section ? this.selectors.find(s => document.querySelector(s)) : null
    };
  },
  
  /**
   * Extract about text for completeness scoring
   * @returns {Object} Basic about data with character count
   */
  async extract() {
    const startTime = Date.now();
    const scanResult = await this.scan();
    
    if (!scanResult.exists) {
      Logger.info('[AboutExtractor] About section not found');
      return {
        exists: false,
        charCount: 0,
        text: '',
        hasShowMore: false
      };
    }
    
    const section = BaseExtractor.findSection(this.selectors, 'About');
    
    // Try to extract text using multiple strategies
    let text = '';
    
    // Strategy 1: Try each text selector
    for (const selector of this.textSelectors) {
      const elements = section.querySelectorAll(selector);
      if (elements.length > 0) {
        text = Array.from(elements)
          .map(el => el.textContent?.trim())
          .filter(t => t)
          .join(' ');
        
        if (text.length > 0) {
          Logger.debug(`[AboutExtractor] Found text with selector: ${selector}`);
          break;
        }
      }
    }
    
    // Strategy 2: If no text found, try getting all text content
    if (!text) {
      const container = section.querySelector('.pvs-list__outer-container, .pv-about__summary-text');
      if (container) {
        text = BaseExtractor.extractTextContent(container);
      }
    }
    
    // Strategy 3: Last resort - get all visible text
    if (!text) {
      const visibleText = section.innerText || section.textContent || '';
      // Remove common UI elements
      text = visibleText
        .replace(/About\s*$/i, '')
        .replace(/Show\s+more\s*/gi, '')
        .replace(/Show\s+less\s*/gi, '')
        .trim();
    }
    
    const result = {
      exists: true,
      charCount: text.length,
      text: text.substring(0, 500), // Limit for basic extraction
      hasShowMore: scanResult.hasShowMore,
      wordCount: text.split(/\s+/).filter(w => w.length > 0).length,
      paragraphs: text.split(/\n\n+/).filter(p => p.trim()).length
    };
    
    Logger.info(`[AboutExtractor] Extracted ${result.charCount} characters in ${Date.now() - startTime}ms`);
    
    return result;
  },
  
  /**
   * Deep extraction for AI analysis
   * @returns {Object} Detailed about data with full text
   */
  async extractDeep() {
    const startTime = Date.now();
    const basicData = await this.extract();
    
    if (!basicData.exists) return basicData;
    
    const section = BaseExtractor.findSection(this.selectors, 'About');
    
    // Expand "Show more" if present
    if (basicData.hasShowMore) {
      Logger.debug('[AboutExtractor] Clicking "Show more" button');
      await this.expandAboutSection(section);
    }
    
    // Re-extract after expansion
    let fullText = '';
    
    // Try all text extraction strategies again
    for (const selector of this.textSelectors) {
      const elements = section.querySelectorAll(selector);
      if (elements.length > 0) {
        fullText = Array.from(elements)
          .map(el => el.textContent?.trim())
          .filter(t => t)
          .join(' ');
        
        if (fullText.length > 0) break;
      }
    }
    
    // Fallback to container text
    if (!fullText) {
      const container = section.querySelector('.pvs-list__outer-container, .pv-about__summary-text');
      if (container) {
        fullText = BaseExtractor.extractTextContent(container);
      }
    }
    
    // Clean up the text
    fullText = this.cleanAboutText(fullText);
    
    const result = {
      ...basicData,
      text: fullText,
      charCount: fullText.length,
      wordCount: fullText.split(/\s+/).filter(w => w.length > 0).length,
      
      // Analysis features
      paragraphs: this.extractParagraphs(fullText),
      keywords: this.extractKeywords(fullText),
      hasCallToAction: this.hasCallToAction(fullText),
      hasContactInfo: this.hasContactInfo(fullText),
      sentiment: this.analyzeSentiment(fullText),
      readabilityScore: this.calculateReadability(fullText),
      
      // For AI processing
      textChunks: BaseExtractor.chunkText(fullText, 1000)
    };
    
    Logger.info(`[AboutExtractor] Deep extraction completed in ${Date.now() - startTime}ms`, {
      charCount: result.charCount,
      chunks: result.textChunks.length
    });
    
    return result;
  },
  
  /**
   * Expand the about section by clicking "Show more"
   * @param {Element} section - About section element
   */
  async expandAboutSection(section) {
    const showMoreSelectors = [
      'button[aria-label*="more about"]',
      'button[aria-label*="Show more"]',
      'button.inline-show-more-text__button',
      '[class*="inline-show-more-text"] button'
    ];
    
    for (const selector of showMoreSelectors) {
      const button = section.querySelector(selector);
      if (button && !button.disabled) {
        try {
          button.click();
          // Wait for content to load
          await new Promise(resolve => setTimeout(resolve, 1000));
          Logger.debug('[AboutExtractor] Successfully expanded About section');
          return true;
        } catch (error) {
          Logger.warn('[AboutExtractor] Failed to click show more button', error);
        }
      }
    }
    
    return false;
  },
  
  /**
   * Clean about text by removing UI elements
   * @param {string} text - Raw text
   * @returns {string} Cleaned text
   */
  cleanAboutText(text) {
    return text
      .replace(/^About\s*/i, '')
      .replace(/Show\s+more\s*/gi, '')
      .replace(/Show\s+less\s*/gi, '')
      .replace(/\s+/g, ' ')
      .trim();
  },
  
  /**
   * Extract paragraphs from text
   * @param {string} text - About text
   * @returns {Array<string>} Paragraphs
   */
  extractParagraphs(text) {
    return text
      .split(/\n{2,}/)
      .map(p => p.trim())
      .filter(p => p.length > 0);
  },
  
  /**
   * Extract keywords from about text
   * @param {string} text - About text
   * @returns {Array<string>} Keywords
   */
  extractKeywords(text) {
    const commonWords = new Set([
      'the', 'be', 'to', 'of', 'and', 'a', 'in', 'that', 'have', 
      'i', 'it', 'for', 'not', 'on', 'with', 'he', 'as', 'you', 
      'do', 'at', 'this', 'but', 'his', 'by', 'from'
    ]);
    
    const words = text.toLowerCase()
      .replace(/[^\w\s]/g, ' ')
      .split(/\s+/)
      .filter(word => word.length > 3 && !commonWords.has(word));
    
    // Count frequency
    const frequency = {};
    words.forEach(word => {
      frequency[word] = (frequency[word] || 0) + 1;
    });
    
    // Return top keywords
    return Object.entries(frequency)
      .filter(([_, count]) => count > 1)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10)
      .map(([word]) => word);
  },
  
  /**
   * Check if about section has a call to action
   * @param {string} text - About text
   * @returns {boolean}
   */
  hasCallToAction(text) {
    const ctaPatterns = [
      /contact\s+me/i,
      /reach\s+out/i,
      /get\s+in\s+touch/i,
      /let's\s+connect/i,
      /feel\s+free\s+to/i,
      /don't\s+hesitate/i,
      /available\s+for/i,
      /looking\s+for/i,
      /open\s+to/i
    ];
    
    return ctaPatterns.some(pattern => pattern.test(text));
  },
  
  /**
   * Check if about section contains contact information
   * @param {string} text - About text
   * @returns {boolean}
   */
  hasContactInfo(text) {
    const contactPatterns = [
      /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/, // Email
      /\b\d{3}[-.]?\d{3}[-.]?\d{4}\b/, // Phone
      /\bwww\.[a-zA-Z0-9-]+\.[a-zA-Z]{2,}\b/, // Website
      /\bhttps?:\/\/[^\s]+/i // URL
    ];
    
    return contactPatterns.some(pattern => pattern.test(text));
  },
  
  /**
   * Simple sentiment analysis
   * @param {string} text - About text
   * @returns {string} Sentiment (positive/neutral/negative)
   */
  analyzeSentiment(text) {
    const positive = [
      'passionate', 'excited', 'love', 'enjoy', 'enthusiastic',
      'dedicated', 'driven', 'motivated', 'inspire', 'achieve'
    ];
    
    const negative = [
      'frustrated', 'disappointed', 'difficult', 'challenge',
      'struggle', 'problem', 'issue', 'concern'
    ];
    
    const lowerText = text.toLowerCase();
    let score = 0;
    
    positive.forEach(word => {
      if (lowerText.includes(word)) score++;
    });
    
    negative.forEach(word => {
      if (lowerText.includes(word)) score--;
    });
    
    return score > 1 ? 'positive' : score < -1 ? 'negative' : 'neutral';
  },
  
  /**
   * Calculate readability score (simplified Flesch Reading Ease)
   * @param {string} text - About text
   * @returns {number} Readability score
   */
  calculateReadability(text) {
    const sentences = text.split(/[.!?]+/).filter(s => s.trim()).length || 1;
    const words = text.split(/\s+/).filter(w => w).length || 1;
    const syllables = text.toLowerCase().replace(/[^a-z]/g, '').replace(/[aeiou]/gi, '').length || 1;
    
    const avgWordsPerSentence = words / sentences;
    const avgSyllablesPerWord = syllables / words;
    
    // Simplified Flesch Reading Ease formula
    const score = 206.835 - 1.015 * avgWordsPerSentence - 84.6 * avgSyllablesPerWord;
    
    // Normalize to 0-100
    return Math.max(0, Math.min(100, score));
  }
};


  /* ============================================
   * MODULE: extractors/experience.js
   * ============================================ */
/**
 * Experience Extractor Module for ElevateLI
 * Handles extraction of LinkedIn profile experience section
 * This module will be concatenated into analyzer.js for Manifest V3 compatibility
 */

const ExperienceExtractor = {
  name: 'experience',
  
  selectors: [
    'section#experience-section',
    'section[data-section="experience"]',
    'div[data-view-name="profile-card"][id*="experience"]',
    'section:has(#experience)',
    'div:has(#experience)'
  ],
  
  /**
   * Quick scan for experience section existence
   * @returns {Object} Scan results
   */
  async scan() {
    const startTime = Date.now();
    
    const section = BaseExtractor.findSection(this.selectors, 'Experience');
    const exists = !!section;
    
    let visibleCount = 0;
    let totalCount = 0;
    let showAllUrl = null;
    
    if (exists) {
      // Quick count of visible items
      const visibleItems = section.querySelectorAll('.pvs-list__paged-list-item, .artdeco-list__item');
      visibleCount = visibleItems.length;
      
      // Extract "Show all" info without clicking
      const showAllInfo = BaseExtractor.extractShowAllInfo(section, 'experience');
      totalCount = showAllInfo.totalCount || visibleCount;
      showAllUrl = showAllInfo.showAllUrl;
    }
    
    BaseExtractor.logTiming('Experience scan', startTime);
    Logger.info(`[ExperienceExtractor] Scan result:`, {
      exists,
      visibleCount,
      totalCount,
      hasMore: totalCount > visibleCount,
      showAllUrl: showAllUrl ? 'found' : 'not found'
    });
    
    return {
      exists,
      visibleCount,
      totalCount,
      hasMore: totalCount > visibleCount,
      showAllUrl
    };
  },
  
  /**
   * Extract experience data for completeness scoring
   * @returns {Object} Basic experience data with total count
   */
  async extract() {
    const startTime = Date.now();
    const scanResult = await this.scan();
    
    if (!scanResult.exists) {
      return {
        exists: false,
        count: 0,
        totalMonths: 0,
        hasCurrentRole: false
      };
    }
    
    const section = BaseExtractor.findSection(this.selectors, 'Experience');
    
    // Use totalCount from scan (already extracted from "Show all")
    const totalCount = scanResult.totalCount || scanResult.visibleCount;
    
    // Calculate total months and check for current role
    const basicInfo = await this.extractBasicInfo(section);
    
    const result = {
      exists: true,
      count: totalCount,
      totalMonths: basicInfo.totalMonths,
      hasCurrentRole: basicInfo.hasCurrentRole,
      visibleCount: scanResult.visibleCount,
      hasMoreItems: totalCount > scanResult.visibleCount,
      showAllUrl: scanResult.showAllUrl
    };
    
    BaseExtractor.logTiming('Experience extract', startTime);
    return result;
  },
  
  /**
   * Deep extraction for AI analysis
   * @returns {Object} Detailed experience data
   */
  async extractDeep() {
    const startTime = Date.now();
    const basicData = await this.extract();
    
    if (!basicData.exists) return basicData;
    
    const section = BaseExtractor.findSection(this.selectors, 'Experience');
    
    // Expand section if needed
    if (basicData.hasMoreItems) {
      await BaseExtractor.expandSection(section, 'button[aria-label*="Show all"]');
    }
    
    // Expand all "Show more" buttons within experience descriptions
    await this.expandAllDescriptions(section);
    
    // Extract detailed experience items
    const experiences = await this.extractDetailedExperiences(section);
    
    const result = {
      ...basicData,
      experiences: experiences,
      
      // Analysis metrics
      averageTenure: this.calculateAverageTenure(experiences),
      careerProgression: this.analyzeCareerProgression(experiences),
      industryChanges: this.countIndustryChanges(experiences),
      hasQuantifiedAchievements: experiences.some(e => e.hasQuantifiedAchievements),
      hasTechStack: experiences.some(e => e.hasTechStack),
      
      // Content quality metrics
      averageDescriptionLength: this.calculateAverageDescriptionLength(experiences),
      rolesWithDescriptions: experiences.filter(e => e.description || e.bullets.length > 0).length,
      totalBulletPoints: experiences.reduce((sum, e) => sum + e.bullets.length, 0),
      
      // For AI processing
      experienceChunks: this.prepareForAI(experiences)
    };
    
    BaseExtractor.logTiming('Experience deep extract', startTime);
    Logger.info('[ExperienceExtractor] Deep extraction complete:', {
      totalRoles: experiences.length,
      withDescriptions: result.rolesWithDescriptions,
      withAchievements: result.hasQuantifiedAchievements,
      withTechStack: result.hasTechStack,
      avgDescLength: result.averageDescriptionLength
    });
    
    return result;
  },
  
  /**
   * Extract total count from "Show all" button
   * @param {Element} section - Experience section
   * @returns {number} Total count
   */
  async extractTotalCount(section) {
    const showAllSelectors = [
      'a[href*="/details/experience"]',
      'a[aria-label*="Show all"]',
      'button[aria-label*="Show all"]'
    ];
    
    for (const selector of showAllSelectors) {
      const showAllElement = section.querySelector(selector);
      if (showAllElement) {
        const text = showAllElement.textContent || showAllElement.getAttribute('aria-label') || '';
        
        const patterns = [
          /Show all (\d+) experiences?/i,
          /(\d+)\s*experiences?/i,
          /(\d+)\s*positions?/i
        ];
        
        for (const pattern of patterns) {
          const match = text.match(pattern);
          if (match) {
            return parseInt(match[1]);
          }
        }
      }
    }
    
    return 0;
  },
  
  /**
   * Extract basic info like total months and current role
   * @param {Element} section - Experience section
   * @returns {Object} Basic info
   */
  async extractBasicInfo(section) {
    const items = section.querySelectorAll('.pvs-list__paged-list-item, .artdeco-list__item');
    let totalMonths = 0;
    let hasCurrentRole = false;
    
    for (const item of items) {
      // Check for current role (no end date)
      const dateText = BaseExtractor.extractTextContent(
        item.querySelector('.t-14:not(.t-bold), .pvs-entity__caption-wrapper')
      );
      
      if (dateText && (dateText.includes('Present') || dateText.includes('present'))) {
        hasCurrentRole = true;
      }
      
      // Extract duration if available
      const durationMatch = dateText?.match(/(\d+)\s*(yr|year|mo|month)/gi);
      if (durationMatch) {
        // Simple duration calculation (can be enhanced)
        totalMonths += this.parseDuration(dateText);
      }
    }
    
    return { totalMonths, hasCurrentRole };
  },
  
  /**
   * Extract detailed experience items
   * @param {Element} section - Experience section
   * @returns {Array<Object>} Detailed experiences
   */
  async extractDetailedExperiences(section) {
    const experiences = [];
    const items = section.querySelectorAll('.pvs-list__paged-list-item, .artdeco-list__item');
    
    for (const item of items) {
      const experience = await this.extractExperienceItem(item);
      if (experience.title) {
        experiences.push(experience);
      }
    }
    
    return experiences;
  },
  
  /**
   * Extract single experience item
   * @param {Element} item - Experience item element
   * @returns {Object} Experience data
   */
  async extractExperienceItem(item) {
    const experience = {
      title: '',
      company: '',
      duration: '',
      location: '',
      description: '',
      bullets: [],
      hasQuantifiedAchievements: false,
      hasTechStack: false,
      keywords: []
    };
    
    // Extract title - multiple selectors for different LinkedIn layouts
    const titleSelectors = [
      '.t-bold span[aria-hidden="true"]',
      'h3 span[aria-hidden="true"]',
      '.t-bold:not(.t-14) span',
      '[data-field="job_title"]'
    ];
    
    for (const selector of titleSelectors) {
      const titleElement = item.querySelector(selector);
      if (titleElement) {
        experience.title = BaseExtractor.extractTextContent(titleElement);
        if (experience.title) break;
      }
    }
    
    // Extract company - look for company name in various places
    const companySelectors = [
      '.t-14.t-normal span[aria-hidden="true"]:not(.t-black--light)',
      '.t-14:not(.t-bold) span[aria-hidden="true"]',
      '[data-field="company_name"]',
      'span.t-14.t-normal'
    ];
    
    for (const selector of companySelectors) {
      const companyElement = item.querySelector(selector);
      const text = BaseExtractor.extractTextContent(companyElement);
      // Filter out duration text that might be picked up
      if (text && !text.match(/\d+\s*(yr|year|mo|month)/i)) {
        experience.company = text.split('·')[0].trim(); // Remove employment type
        if (experience.company) break;
      }
    }
    
    // Extract duration and location
    const captionElements = item.querySelectorAll('.pvs-entity__caption-wrapper, .t-14.t-normal.t-black--light');
    captionElements.forEach(element => {
      const text = BaseExtractor.extractTextContent(element);
      if (text) {
        // Check if it's duration (contains time indicators)
        if (text.match(/\d+\s*(yr|year|mo|month)/i) || text.includes('Present')) {
          experience.duration = text;
        }
        // Check if it's location (contains location indicators)
        else if (text.includes(',') || text.match(/Remote|On-site|Hybrid/i)) {
          experience.location = text;
        }
      }
    });
    
    // Extract description and bullet points
    const descriptionSelectors = [
      '.pvs-list__outer-container > ul',
      '.pv-shared-text-with-see-more',
      '[data-field="description"]',
      '.inline-show-more-text'
    ];
    
    for (const selector of descriptionSelectors) {
      const descContainer = item.querySelector(selector);
      if (descContainer) {
        // Check for bullet points
        const bullets = descContainer.querySelectorAll('li');
        if (bullets.length > 0) {
          bullets.forEach(bullet => {
            const bulletText = BaseExtractor.extractTextContent(bullet);
            if (bulletText && bulletText.length > 10) { // Filter out empty or very short bullets
              experience.bullets.push(bulletText);
            }
          });
          // Combine bullets into description
          experience.description = experience.bullets.join(' • ');
        } else {
          // Single paragraph description
          experience.description = BaseExtractor.extractTextContent(descContainer);
        }
        
        if (experience.description) break;
      }
    }
    
    // Analyze content
    const fullContent = experience.description || experience.bullets.join(' ');
    if (fullContent) {
      experience.hasQuantifiedAchievements = this.hasQuantifiedAchievements(fullContent);
      experience.hasTechStack = this.hasTechStack(fullContent);
      experience.keywords = this.extractKeywords(fullContent);
    }
    
    return experience;
  },
  
  /**
   * Check for quantified achievements
   * @param {string} text - Description text
   * @returns {boolean}
   */
  hasQuantifiedAchievements(text) {
    const pattern = /\d+[%+,kKmMbB$]*\s*(revenue|users|customers|growth|increase|decrease|ROI|saved|generated|improvement|reduction)/gi;
    return pattern.test(text);
  },
  
  /**
   * Check for tech stack mentions
   * @param {string} text - Description text
   * @returns {boolean}
   */
  hasTechStack(text) {
    const techPattern = /\b(React|Angular|Vue|Node|Python|Java|JavaScript|AWS|Azure|Docker|Kubernetes|SQL|API)\b/gi;
    return techPattern.test(text);
  },
  
  /**
   * Extract keywords from text
   * @param {string} text - Description text
   * @returns {Array<string>}
   */
  extractKeywords(text) {
    const techPattern = /\b(React|Angular|Vue|Node|Python|Java|JavaScript|AWS|Azure|Docker|Kubernetes|SQL|API)\b/gi;
    const matches = text.match(techPattern) || [];
    return [...new Set(matches.map(k => k.toLowerCase()))];
  },
  
  /**
   * Parse duration string to months
   * @param {string} duration - Duration text
   * @returns {number} Total months
   */
  parseDuration(duration) {
    let months = 0;
    
    const yearMatch = duration.match(/(\d+)\s*(yr|year)/i);
    if (yearMatch) {
      months += parseInt(yearMatch[1]) * 12;
    }
    
    const monthMatch = duration.match(/(\d+)\s*(mo|month)/i);
    if (monthMatch) {
      months += parseInt(monthMatch[1]);
    }
    
    return months;
  },
  
  /**
   * Calculate average tenure
   * @param {Array<Object>} experiences - Experience items
   * @returns {number} Average months per role
   */
  calculateAverageTenure(experiences) {
    if (experiences.length === 0) return 0;
    
    const totalMonths = experiences.reduce((sum, exp) => {
      return sum + this.parseDuration(exp.duration);
    }, 0);
    
    return Math.round(totalMonths / experiences.length);
  },
  
  /**
   * Analyze career progression
   * @param {Array<Object>} experiences - Experience items
   * @returns {string} Progression analysis
   */
  analyzeCareerProgression(experiences) {
    if (experiences.length < 2) return 'insufficient_data';
    
    const titles = experiences.map(e => e.title.toLowerCase());
    const progressionIndicators = ['senior', 'lead', 'principal', 'manager', 'director', 'vp', 'chief'];
    
    let progressionScore = 0;
    for (let i = 1; i < titles.length; i++) {
      const currentLevel = progressionIndicators.findIndex(ind => titles[i].includes(ind));
      const previousLevel = progressionIndicators.findIndex(ind => titles[i-1].includes(ind));
      
      if (currentLevel > previousLevel) progressionScore++;
    }
    
    return progressionScore > experiences.length / 3 ? 'upward' : 'lateral';
  },
  
  /**
   * Count industry changes
   * @param {Array<Object>} experiences - Experience items
   * @returns {number} Number of industry changes
   */
  countIndustryChanges(experiences) {
    // Simplified - could be enhanced with industry detection
    const companies = experiences.map(e => e.company);
    const uniqueCompanies = new Set(companies);
    return Math.max(0, uniqueCompanies.size - 1);
  },
  
  /**
   * Prepare experiences for AI processing
   * @param {Array<Object>} experiences - Experience items
   * @returns {Array<Object>} Chunked data for AI
   */
  prepareForAI(experiences) {
    return experiences.map(exp => ({
      title: exp.title,
      company: exp.company,
      duration: exp.duration,
      location: exp.location,
      description: exp.description,
      bullets: exp.bullets,
      // Chunk large descriptions
      descriptionChunks: BaseExtractor.chunkText(exp.description, 500),
      metrics: {
        hasQuantifiedAchievements: exp.hasQuantifiedAchievements,
        hasTechStack: exp.hasTechStack,
        keywordCount: exp.keywords.length,
        bulletCount: exp.bullets.length,
        descriptionLength: exp.description.length
      }
    }));
  },
  
  /**
   * Expand all "Show more" buttons within experience descriptions
   * @param {Element} section - Experience section
   */
  async expandAllDescriptions(section) {
    const showMoreSelectors = [
      'button[aria-label*="more"][aria-label*="description"]',
      'button.inline-show-more-text__button',
      'button[data-control-name="see_more"]',
      '.see-more-inline button'
    ];
    
    let expanded = false;
    for (const selector of showMoreSelectors) {
      const buttons = section.querySelectorAll(selector);
      for (const button of buttons) {
        if (button && button.offsetParent !== null) {
          Logger.debug('[ExperienceExtractor] Clicking show more button');
          button.click();
          expanded = true;
          await BaseExtractor.wait(300);
        }
      }
    }
    
    if (expanded) {
      await BaseExtractor.wait(500); // Wait for content to load
    }
  },
  
  /**
   * Calculate average description length
   * @param {Array<Object>} experiences - Experience items
   * @returns {number} Average length
   */
  calculateAverageDescriptionLength(experiences) {
    const withDescriptions = experiences.filter(e => e.description || e.bullets.length > 0);
    if (withDescriptions.length === 0) return 0;
    
    const totalLength = withDescriptions.reduce((sum, exp) => {
      const descLength = exp.description ? exp.description.length : 0;
      const bulletsLength = exp.bullets.reduce((s, b) => s + b.length, 0);
      return sum + descLength + bulletsLength;
    }, 0);
    
    return Math.round(totalLength / withDescriptions.length);
  }
};


  /* ============================================
   * MODULE: extractors/skills.js
   * ============================================ */
/**
 * Skills Extractor Module for ElevateLI
 * Handles extraction of LinkedIn profile skills section
 * This module will be concatenated into analyzer.js for Manifest V3 compatibility
 */

const SkillsExtractor = {
  name: 'skills',
  
  // Multiple selectors for LinkedIn's changing DOM
  selectors: [
    'section[data-section="skills"]',
    'section.pv-skill-categories-section',
    'div[id*="skills-section"]',
    '#skills',
    'div[data-view-name="profile-card"][id*="skills"]',
    // New pattern: anchor + sibling
    '#skills.pv-profile-card__anchor + div',
    '#skills ~ div'
  ],
  
  // Selectors for skill items
  skillItemSelectors: [
    'li.artdeco-list__item',
    '.pvs-list__paged-list-item',
    '.pv-skill-category-entity',
    '.pv-skill-entity',
    '[data-field="skill_card_skill_topic"]',
    // Additional selectors for current LinkedIn
    'div[class*="pvs-entity"]',
    'li[class*="pvs-list__item"]',
    'div.pvs-entity',
    'li.pvs-list__item--line-separated'
  ],
  
  /**
   * Quick scan for skills section existence
   * @returns {Object} Scan results
   */
  async scan() {
    const startTime = Date.now();
    
    Logger.info('[SkillsExtractor] Starting scan v3 - CUSTOM SECTION FINDER');
    
    // Custom section finding for skills - look for anchor and get the right sibling
    const anchor = document.querySelector('div#skills.pv-profile-card__anchor');
    let section = null;
    
    if (anchor) {
      Logger.info('[SkillsExtractor] Found skills anchor, checking siblings');
      let sibling = anchor.nextElementSibling;
      let siblingIndex = 0;
      
      while (sibling && siblingIndex < 5) {
        const skillLinks = sibling.querySelectorAll('[data-field="skill_card_skill_topic"]');
        const showAllLink = sibling.querySelector('a[href*="/details/skills"]');
        
        Logger.info(`[SkillsExtractor] Sibling ${siblingIndex}: ${skillLinks.length} skill links, showAll: ${!!showAllLink}`);
        
        // We want the sibling with actual skill items
        if (skillLinks.length > 0) {
          section = sibling;
          Logger.info(`[SkillsExtractor] Found skills section at sibling ${siblingIndex} with ${skillLinks.length} skills`);
          break;
        }
        
        sibling = sibling.nextElementSibling;
        siblingIndex++;
      }
    }
    
    // Fallback to BaseExtractor if custom method fails
    if (!section) {
      Logger.info('[SkillsExtractor] Custom section finder failed, using BaseExtractor');
      section = BaseExtractor.findSection(this.selectors, 'Skills');
    }
    
    const exists = !!section;
    
    if (section) {
      Logger.info(`[SkillsExtractor] Section found: ${exists}, tagName: ${section.tagName}, id: ${section.id || 'none'}, classes: ${section.className}`);
    } else {
      Logger.info('[SkillsExtractor] No section found');
    }
    
    let visibleCount = 0;
    let totalCount = 0;
    let showAllUrl = null;
    
    if (exists) {
      // Debug: log the section HTML structure
      Logger.info('[SkillsExtractor] Section EXISTS, checking for skill items');
      Logger.info('[SkillsExtractor] Section HTML preview (first 500 chars):', section.innerHTML.substring(0, 500).replace(/\s+/g, ' '));
      
      // Check section structure
      const sectionId = section.getAttribute('id');
      const sectionClasses = section.getAttribute('class');
      Logger.info(`[SkillsExtractor] Section ID: "${sectionId}", Classes: "${sectionClasses}"`);
      
      // Look for the actual skills container
      const containers = section.querySelectorAll('div[class*="pvs-list"], ul');
      Logger.info(`[SkillsExtractor] Found ${containers.length} potential containers`);
      containers.forEach((container, idx) => {
        const containerClasses = container.getAttribute('class');
        const childCount = container.children.length;
        Logger.info(`[SkillsExtractor] Container ${idx}: class="${containerClasses}", children=${childCount}`);
      });
      
      // Count visible skill items - specifically look for skill topic links
      const skillLinks = section.querySelectorAll('a[data-field="skill_card_skill_topic"]');
      Logger.info(`[SkillsExtractor] Found ${skillLinks.length} skill topic links`);
      
      if (skillLinks.length > 0) {
        visibleCount = skillLinks.length;
        
        // Log first few skills for verification
        skillLinks.forEach((link, i) => {
          if (i < 3) {
            const skillName = link.querySelector('span[aria-hidden="true"]')?.textContent?.trim();
            Logger.info(`[SkillsExtractor] Skill ${i}: ${skillName}`);
          }
        });
      } else {
        // Fallback to other selectors if skill topic links not found
        for (const selector of this.skillItemSelectors) {
          const items = section.querySelectorAll(selector);
          Logger.info(`[SkillsExtractor] Fallback - trying selector "${selector}" - found ${items.length} items`);
          if (items.length > 0) {
            // Additional filtering to ensure we're getting skills, not endorsements
            const filteredItems = Array.from(items).filter(item => {
              // Check if item contains skill link or looks like a skill
              return item.querySelector('[data-field="skill_card_skill_topic"]') || 
                     (item.textContent.length < 100 && !item.textContent.includes('endorsement'));
            });
            if (filteredItems.length > 0) {
              visibleCount = filteredItems.length;
              Logger.info(`[SkillsExtractor] Filtered to ${visibleCount} actual skill items`);
              break;
            }
          }
        }
      }
      
      // If no items found with standard selectors, try a broader search
      if (visibleCount === 0) {
        Logger.info('[SkillsExtractor] No items found with standard selectors, trying broader search');
        
        // Log the section structure for debugging
        const sectionHTML = section.innerHTML.substring(0, 1000);
        Logger.info('[SkillsExtractor] Section HTML preview:', sectionHTML);
        
        // Try finding any list items
        const allListItems = section.querySelectorAll('li');
        Logger.info(`[SkillsExtractor] Found ${allListItems.length} total li elements`);
        
        // Try finding divs that might contain skills
        const skillDivs = section.querySelectorAll('div[class*="entity"], div[class*="skill"]');
        Logger.info(`[SkillsExtractor] Found ${skillDivs.length} potential skill divs`);
        
        // Check all lists
        const allLists = section.querySelectorAll('ul');
        Logger.info(`[SkillsExtractor] Found ${allLists.length} ul elements in section`);
        
        allLists.forEach((list, index) => {
          const listItems = list.querySelectorAll('li');
          if (listItems.length > 0 && visibleCount === 0) {
            const firstItem = listItems[0];
            const itemText = firstItem.textContent.trim();
            
            // Log first item for debugging
            Logger.info(`[SkillsExtractor] List ${index} first item text: "${itemText.substring(0, 50)}..."`);
            
            // More flexible skill detection
            const hasSkillLink = firstItem.querySelector('a[data-field*="skill"], a[href*="skill"]');
            const hasSpanWithText = firstItem.querySelector('span[aria-hidden="true"]');
            const looksLikeSkill = itemText.length > 1 && itemText.length < 200 && 
                                  !itemText.toLowerCase().includes('show') && 
                                  !itemText.toLowerCase().includes('see more') &&
                                  !itemText.toLowerCase().includes('load');
            
            if (hasSkillLink || hasSpanWithText || looksLikeSkill) {
              visibleCount = listItems.length;
              Logger.info(`[SkillsExtractor] Found skills in list ${index} with ${listItems.length} items`);
            }
          }
        });
      }
      
      // First try specific skills details link
      const detailsLinks = section.querySelectorAll('a[href*="/details/"], a[href*="skills"]');
      Logger.info(`[SkillsExtractor] Found ${detailsLinks.length} potential details links`);
      detailsLinks.forEach((link, idx) => {
        const href = link.getAttribute('href') || '';
        const text = link.textContent || '';
        Logger.info(`[SkillsExtractor] Link ${idx}: href="${href}", text="${text.substring(0, 50)}"`);
      });
      
      const showAllLink = section.querySelector('a[href*="/details/skills"]');
      if (showAllLink) {
        const linkText = showAllLink.textContent || '';
        Logger.info(`[SkillsExtractor] Found show all link with text: "${linkText}"`);
        
        // Try multiple patterns
        const patterns = [
          /Show\s+all\s+(\d+)\s+skills?/i,
          /(\d+)\s+skills?/i,
          /All\s+(\d+)/i
        ];
        
        for (const pattern of patterns) {
          const match = linkText.match(pattern);
          if (match) {
            totalCount = parseInt(match[1]);
            showAllUrl = showAllLink.href;
            Logger.info(`[SkillsExtractor] Found total count from link: ${totalCount}`);
            break;
          }
        }
      }
      
      // Fallback to generic extractShowAllInfo
      if (totalCount === 0) {
        const showAllInfo = BaseExtractor.extractShowAllInfo(section, 'skills');
        totalCount = showAllInfo.totalCount || visibleCount;
        showAllUrl = showAllInfo.showAllUrl;
      }
    }
    
    Logger.info(`[SkillsExtractor] Scan completed in ${Date.now() - startTime}ms`, {
      exists,
      visibleCount,
      totalCount,
      hasMore: totalCount > visibleCount,
      showAllUrl: showAllUrl ? 'found' : 'not found'
    });
    
    return {
      exists,
      visibleCount,
      totalCount,
      hasMore: totalCount > visibleCount,
      showAllUrl
    };
  },
  
  /**
   * Extract skills data for completeness scoring
   * @returns {Object} Basic skills data with total count
   */
  async extract() {
    const startTime = Date.now();
    const scanResult = await this.scan();
    
    if (!scanResult.exists) {
      Logger.info('[SkillsExtractor] Skills section not found');
      return {
        exists: false,
        count: 0,
        skills: []
      };
    }
    
    const section = BaseExtractor.findSection(this.selectors, 'Skills');
    
    // Use totalCount from scan (already extracted from "Show all")
    const totalCount = scanResult.totalCount || scanResult.visibleCount;
    
    // Extract visible skills for basic data
    const visibleSkills = await this.extractVisibleSkills(section);
    
    const result = {
      exists: true,
      count: totalCount,
      visibleCount: scanResult.visibleCount,
      hasMoreSkills: totalCount > scanResult.visibleCount,
      skills: visibleSkills.slice(0, 5), // Just top 5 for basic extraction
      hasEndorsements: visibleSkills.some(s => s.endorsementCount > 0),
      showAllUrl: scanResult.showAllUrl
    };
    
    Logger.info(`[SkillsExtractor] Extracted ${totalCount} total skills (${scanResult.visibleCount} visible) in ${Date.now() - startTime}ms`);
    
    return result;
  },
  
  /**
   * Deep extraction for AI analysis
   * @returns {Object} Detailed skills data
   */
  async extractDeep() {
    const startTime = Date.now();
    const basicData = await this.extract();
    
    if (!basicData.exists) return basicData;
    
    const section = BaseExtractor.findSection(this.selectors, 'Skills');
    
    // Expand section if needed
    if (basicData.hasMoreSkills) {
      Logger.debug('[SkillsExtractor] Clicking "Show all" for skills');
      await this.expandSkillsSection(section);
      
      // Wait for skills to load
      await new Promise(resolve => setTimeout(resolve, 2000));
    }
    
    // Extract all skills after expansion
    const allSkills = await this.extractAllSkills(section);
    
    const result = {
      ...basicData,
      count: allSkills.length,
      skills: allSkills,
      
      // Analysis features
      skillsByCategory: this.categorizeSkills(allSkills),
      topEndorsedSkills: this.getTopEndorsedSkills(allSkills),
      skillKeywords: this.extractSkillKeywords(allSkills),
      technicalSkills: allSkills.filter(s => this.isTechnicalSkill(s.name)),
      softSkills: allSkills.filter(s => this.isSoftSkill(s.name)),
      
      // Metrics
      totalEndorsements: allSkills.reduce((sum, s) => sum + s.endorsementCount, 0),
      averageEndorsements: allSkills.length > 0 
        ? Math.round(allSkills.reduce((sum, s) => sum + s.endorsementCount, 0) / allSkills.length)
        : 0,
      endorsedSkillsCount: allSkills.filter(s => s.endorsementCount > 0).length,
      
      // For AI processing
      skillGroups: this.groupSkillsForAI(allSkills)
    };
    
    Logger.info(`[SkillsExtractor] Deep extraction completed in ${Date.now() - startTime}ms`, {
      totalSkills: result.count,
      endorsed: result.endorsedSkillsCount,
      categories: Object.keys(result.skillsByCategory).length
    });
    
    return result;
  },
  
  /**
   * Extract total count from "Show all" button
   * @param {Element} section - Skills section
   * @returns {number} Total count
   */
  async extractTotalCount(section) {
    const showAllSelectors = [
      'a[aria-label*="Show all"][aria-label*="skills"]',
      'button[aria-label*="Show all"][aria-label*="skills"]',
      'a[href*="/details/skills"]',
      '.pvs-list__footer-wrapper a'
    ];
    
    for (const selector of showAllSelectors) {
      const element = section.querySelector(selector);
      if (element) {
        const text = element.textContent || element.getAttribute('aria-label') || '';
        
        // Try different patterns
        const patterns = [
          /Show all (\d+) skills?/i,
          /(\d+)\s*skills?/i,
          /View all\s*\((\d+)\)/i
        ];
        
        for (const pattern of patterns) {
          const match = text.match(pattern);
          if (match) {
            const count = parseInt(match[1]);
            Logger.debug(`[SkillsExtractor] Found total count from button: ${count}`);
            return count;
          }
        }
      }
    }
    
    return 0;
  },
  
  /**
   * Extract visible skills from the page
   * @param {Element} section - Skills section
   * @returns {Array<Object>} Skills data
   */
  async extractVisibleSkills(section) {
    const skills = [];
    
    // First try to find skill topic links (most accurate)
    let skillElements = Array.from(section.querySelectorAll('a[data-field="skill_card_skill_topic"]'));
    
    if (skillElements.length === 0) {
      // Fallback to other selectors if skill topic links not found
      for (const selector of this.skillItemSelectors) {
        const items = Array.from(section.querySelectorAll(selector));
        // Filter to ensure we're getting skills, not endorsements
        skillElements = items.filter(item => {
          return item.querySelector('[data-field="skill_card_skill_topic"]') || 
                 (item.textContent.length < 100 && !item.textContent.includes('endorsement'));
        });
        if (skillElements.length > 0) break;
      }
    }
    
    // Extract skill data from elements
    for (const element of skillElements) {
      if (element.tagName === 'A' && element.hasAttribute('data-field')) {
        // Direct skill link
        const skillName = element.querySelector('span[aria-hidden="true"]')?.textContent?.trim();
        if (skillName) {
          skills.push({
            name: skillName,
            endorsementCount: 0,
            hasEndorsements: false
          });
        }
      } else {
        // Li element containing skill
        const skill = await this.extractSkillItem(element);
        if (skill.name) {
          skills.push(skill);
        }
      }
    }
    
    return skills;
  },
  
  /**
   * Extract all skills (after expansion)
   * @param {Element} section - Skills section
   * @returns {Array<Object>} All skills data
   */
  async extractAllSkills(section) {
    // Re-query after expansion
    const skills = [];
    
    let skillElements = [];
    for (const selector of this.skillItemSelectors) {
      skillElements = Array.from(section.querySelectorAll(selector));
      if (skillElements.length > 0) break;
    }
    
    Logger.debug(`[SkillsExtractor] Found ${skillElements.length} skill elements after expansion`);
    
    for (const element of skillElements) {
      const skill = await this.extractSkillItem(element);
      if (skill.name) {
        skills.push(skill);
      }
    }
    
    return skills;
  },
  
  /**
   * Extract single skill item
   * @param {Element} element - Skill element
   * @returns {Object} Skill data
   */
  async extractSkillItem(element) {
    const skill = {
      name: '',
      endorsementCount: 0,
      hasEndorsements: false
    };
    
    // Extract skill name
    const nameSelectors = [
      '.hoverable-link-text.t-bold span[aria-hidden="true"]',
      '.t-bold span[aria-hidden="true"]',
      '.pv-skill-entity__skill-name',
      '[data-field="skill_card_skill_topic"] span[aria-hidden="true"]',
      'a[data-field="skill_card_skill_topic"] span[aria-hidden="true"]'
    ];
    
    for (const selector of nameSelectors) {
      const nameEl = element.querySelector(selector);
      if (nameEl) {
        skill.name = BaseExtractor.extractTextContent(nameEl);
        if (skill.name) break;
      }
    }
    
    // Extract endorsement count
    const endorsementEl = element.querySelector('.pv-skill-entity__endorsement-count');
    if (endorsementEl) {
      const text = endorsementEl.textContent || '';
      const match = text.match(/(\d+)/);
      if (match) {
        skill.endorsementCount = parseInt(match[1]);
        skill.hasEndorsements = true;
      }
    } else {
      // Fallback: search for endorsement text
      const textElements = element.querySelectorAll('.t-14, span');
      for (const el of textElements) {
        if (el.textContent && el.textContent.includes('endorsement')) {
          const match = el.textContent.match(/(\d+)/);
          if (match) {
            skill.endorsementCount = parseInt(match[1]);
            skill.hasEndorsements = true;
            break;
          }
        }
      }
    }
    
    return skill;
  },
  
  /**
   * Expand skills section by clicking "Show all"
   * @param {Element} section - Skills section
   */
  async expandSkillsSection(section) {
    const showAllSelectors = [
      'a[aria-label*="Show all"][aria-label*="skills"]',
      'button[aria-label*="Show all"][aria-label*="skills"]',
      'a[href*="/details/skills"]',
      '.pvs-list__footer-wrapper a',
      '.pvs-list__footer-wrapper button'
    ];
    
    for (const selector of showAllSelectors) {
      const button = section.querySelector(selector);
      if (button && !button.disabled) {
        try {
          button.click();
          Logger.debug('[SkillsExtractor] Clicked show all skills button');
          return true;
        } catch (error) {
          Logger.warn('[SkillsExtractor] Failed to click show all button', error);
        }
      }
    }
    
    return false;
  },
  
  /**
   * Categorize skills based on common patterns
   * @param {Array<Object>} skills - Skills array
   * @returns {Object} Categorized skills
   */
  categorizeSkills(skills) {
    const categories = {
      programming: [],
      frameworks: [],
      databases: [],
      cloud: [],
      tools: [],
      soft: [],
      other: []
    };
    
    const patterns = {
      programming: /\b(java|python|javascript|typescript|c\+\+|c#|ruby|go|rust|php|swift|kotlin)\b/i,
      frameworks: /\b(react|angular|vue|django|spring|express|rails|laravel|flutter)\b/i,
      databases: /\b(sql|mysql|postgresql|mongodb|redis|elasticsearch|cassandra)\b/i,
      cloud: /\b(aws|azure|gcp|docker|kubernetes|cloud|devops)\b/i,
      tools: /\b(git|jenkins|jira|agile|scrum|ci\/cd)\b/i,
      soft: /\b(leadership|communication|teamwork|management|problem solving|analytical)\b/i
    };
    
    skills.forEach(skill => {
      let categorized = false;
      
      for (const [category, pattern] of Object.entries(patterns)) {
        if (pattern.test(skill.name)) {
          categories[category].push(skill);
          categorized = true;
          break;
        }
      }
      
      if (!categorized) {
        categories.other.push(skill);
      }
    });
    
    // Remove empty categories
    Object.keys(categories).forEach(key => {
      if (categories[key].length === 0) {
        delete categories[key];
      }
    });
    
    return categories;
  },
  
  /**
   * Get top endorsed skills
   * @param {Array<Object>} skills - Skills array
   * @returns {Array<Object>} Top endorsed skills
   */
  getTopEndorsedSkills(skills) {
    return skills
      .filter(s => s.endorsementCount > 0)
      .sort((a, b) => b.endorsementCount - a.endorsementCount)
      .slice(0, 10);
  },
  
  /**
   * Extract keywords from skills
   * @param {Array<Object>} skills - Skills array
   * @returns {Array<string>} Keywords
   */
  extractSkillKeywords(skills) {
    const keywords = new Set();
    
    skills.forEach(skill => {
      // Split compound skills
      const words = skill.name
        .split(/[\s\-\/&,]+/)
        .filter(w => w.length > 2);
      
      words.forEach(word => keywords.add(word.toLowerCase()));
    });
    
    return Array.from(keywords);
  },
  
  /**
   * Check if skill is technical
   * @param {string} skillName - Skill name
   * @returns {boolean}
   */
  isTechnicalSkill(skillName) {
    const technicalPattern = /\b(programming|software|development|engineering|technical|code|data|system|network|security|database|api|framework|library|platform|technology)\b/i;
    return technicalPattern.test(skillName);
  },
  
  /**
   * Check if skill is soft skill
   * @param {string} skillName - Skill name
   * @returns {boolean}
   */
  isSoftSkill(skillName) {
    const softPattern = /\b(leadership|communication|management|teamwork|problem solving|analytical|creative|strategic|organizational|interpersonal|presentation|negotiation)\b/i;
    return softPattern.test(skillName);
  },
  
  /**
   * Group skills for AI processing
   * @param {Array<Object>} skills - Skills array
   * @returns {Array<Object>} Grouped skills
   */
  groupSkillsForAI(skills) {
    const groups = [];
    const groupSize = 20;
    
    for (let i = 0; i < skills.length; i += groupSize) {
      groups.push({
        skills: skills.slice(i, i + groupSize).map(s => ({
          name: s.name,
          endorsements: s.endorsementCount
        })),
        groupIndex: Math.floor(i / groupSize) + 1,
        totalGroups: Math.ceil(skills.length / groupSize)
      });
    }
    
    return groups;
  }
};


  /* ============================================
   * MODULE: extractors/education.js
   * ============================================ */
/**
 * Education Extractor Module for ElevateLI
 * Handles extraction of LinkedIn profile education section
 * This module will be concatenated into analyzer.js for Manifest V3 compatibility
 */

const EducationExtractor = {
  name: 'education',
  
  selectors: [
    'section#education-section',
    'section[data-section="education"]',
    'div[data-view-name="profile-card"]:has(div#education)',
    'section:has(h2:contains("Education"))',
    'section.pv-education-section',
    'div[id*="education-section"]'
  ],
  
  /**
   * Quick scan for education section existence
   * @returns {Object} Scan results
   */
  async scan() {
    const startTime = Date.now();
    
    const section = BaseExtractor.findSection(this.selectors, 'Education');
    const exists = !!section;
    
    let visibleCount = 0;
    if (exists) {
      // Count visible education items
      const items = section.querySelectorAll('.pvs-list__paged-list-item, .artdeco-list__item');
      visibleCount = items.length;
    }
    
    Logger.debug(`[EducationExtractor] Scan completed in ${Date.now() - startTime}ms`, {
      exists,
      visibleCount
    });
    
    return {
      exists,
      visibleCount
    };
  },
  
  /**
   * Extract education data for completeness scoring
   * @returns {Object} Basic education data
   */
  async extract() {
    const startTime = Date.now();
    const scanResult = await this.scan();
    
    if (!scanResult.exists) {
      Logger.info('[EducationExtractor] Education section not found');
      return {
        exists: false,
        count: 0,
        schools: []
      };
    }
    
    const section = BaseExtractor.findSection(this.selectors, 'Education');
    const educationItems = await this.extractEducationItems(section);
    
    const result = {
      exists: true,
      count: educationItems.length,
      schools: educationItems.map(item => ({
        school: item.school,
        degree: item.degree,
        field: item.field
      })),
      hasUniversity: educationItems.some(item => 
        item.school.toLowerCase().includes('university') || 
        item.school.toLowerCase().includes('college')
      ),
      highestDegree: this.determineHighestDegree(educationItems)
    };
    
    Logger.info(`[EducationExtractor] Extracted ${result.count} education entries in ${Date.now() - startTime}ms`);
    
    return result;
  },
  
  /**
   * Deep extraction for AI analysis
   * @returns {Object} Detailed education data
   */
  async extractDeep() {
    const startTime = Date.now();
    const basicData = await this.extract();
    
    if (!basicData.exists) return basicData;
    
    const section = BaseExtractor.findSection(this.selectors, 'Education');
    const detailedEducation = await this.extractDetailedEducation(section);
    
    const result = {
      ...basicData,
      education: detailedEducation,
      
      // Analysis features
      totalYears: this.calculateTotalEducationYears(detailedEducation),
      recentEducation: detailedEducation.find(e => this.isRecent(e.endDate)),
      hasCertifications: detailedEducation.some(e => e.activities || e.honors),
      fieldsOfStudy: this.extractFieldsOfStudy(detailedEducation),
      
      // For AI processing
      educationSummary: this.summarizeEducation(detailedEducation)
    };
    
    Logger.info(`[EducationExtractor] Deep extraction completed in ${Date.now() - startTime}ms`);
    
    return result;
  },
  
  /**
   * Extract education items
   * @param {Element} section - Education section
   * @returns {Array<Object>} Education items
   */
  async extractEducationItems(section) {
    const items = [];
    const itemElements = section.querySelectorAll('.pvs-list__paged-list-item, .artdeco-list__item');
    
    for (const element of itemElements) {
      const item = await this.extractEducationItem(element);
      if (item.school) {
        items.push(item);
      }
    }
    
    return items;
  },
  
  /**
   * Extract single education item
   * @param {Element} element - Education item element
   * @returns {Object} Education data
   */
  async extractEducationItem(element) {
    const education = {
      school: '',
      degree: '',
      field: '',
      startDate: '',
      endDate: '',
      duration: '',
      description: '',
      activities: '',
      honors: ''
    };
    
    // Extract school name
    const schoolEl = element.querySelector('.t-bold span[aria-hidden="true"], h3 span[aria-hidden="true"]');
    education.school = BaseExtractor.extractTextContent(schoolEl);
    
    // Extract degree and field
    const degreeEl = element.querySelector('.t-14:not(.t-bold) span[aria-hidden="true"]');
    if (degreeEl) {
      const degreeText = BaseExtractor.extractTextContent(degreeEl);
      // Parse degree and field (e.g., "Bachelor of Science - BS, Computer Science")
      const parts = degreeText.split(',');
      if (parts.length > 0) {
        education.degree = parts[0].trim();
        if (parts.length > 1) {
          education.field = parts.slice(1).join(',').trim();
        }
      }
    }
    
    // Extract dates
    const dateEl = element.querySelector('.pvs-entity__caption-wrapper');
    const dateText = BaseExtractor.extractTextContent(dateEl);
    if (dateText) {
      const dateMatch = dateText.match(/(\d{4})\s*-\s*(\d{4}|Present)/i);
      if (dateMatch) {
        education.startDate = dateMatch[1];
        education.endDate = dateMatch[2];
      }
      education.duration = dateText;
    }
    
    // Extract description/activities
    const descEl = element.querySelector('.pvs-list__outer-container > ul li');
    if (descEl) {
      const descText = BaseExtractor.extractTextContent(descEl);
      if (descText.toLowerCase().includes('activities')) {
        education.activities = descText;
      } else {
        education.description = descText;
      }
    }
    
    return education;
  },
  
  /**
   * Extract detailed education information
   * @param {Element} section - Education section
   * @returns {Array<Object>} Detailed education data
   */
  async extractDetailedEducation(section) {
    const detailedItems = await this.extractEducationItems(section);
    
    // Enhance with additional analysis
    return detailedItems.map(item => ({
      ...item,
      degreeLevel: this.classifyDegreeLevel(item.degree),
      fieldCategory: this.categorizeField(item.field),
      isOngoing: item.endDate === 'Present',
      duration: this.calculateDuration(item.startDate, item.endDate)
    }));
  },
  
  /**
   * Determine highest degree level
   * @param {Array<Object>} educationItems - Education items
   * @returns {string} Highest degree
   */
  determineHighestDegree(educationItems) {
    const levels = {
      'phd': 5,
      'doctorate': 5,
      'master': 4,
      'mba': 4,
      'bachelor': 3,
      'associate': 2,
      'certificate': 1
    };
    
    let highest = 'none';
    let highestLevel = 0;
    
    educationItems.forEach(item => {
      const degreeLower = (item.degree || '').toLowerCase();
      
      for (const [degree, level] of Object.entries(levels)) {
        if (degreeLower.includes(degree) && level > highestLevel) {
          highest = degree;
          highestLevel = level;
        }
      }
    });
    
    return highest;
  },
  
  /**
   * Classify degree level
   * @param {string} degree - Degree text
   * @returns {string} Degree level
   */
  classifyDegreeLevel(degree) {
    const degreeLower = degree.toLowerCase();
    
    if (degreeLower.includes('phd') || degreeLower.includes('doctorate')) {
      return 'doctoral';
    } else if (degreeLower.includes('master') || degreeLower.includes('mba')) {
      return 'masters';
    } else if (degreeLower.includes('bachelor')) {
      return 'bachelors';
    } else if (degreeLower.includes('associate')) {
      return 'associates';
    } else if (degreeLower.includes('certificate') || degreeLower.includes('certification')) {
      return 'certificate';
    }
    
    return 'other';
  },
  
  /**
   * Categorize field of study
   * @param {string} field - Field text
   * @returns {string} Field category
   */
  categorizeField(field) {
    const fieldLower = field.toLowerCase();
    
    const categories = {
      'stem': /computer|engineering|mathematics|science|technology|physics|chemistry|biology/i,
      'business': /business|management|finance|marketing|economics|accounting|mba/i,
      'arts': /art|design|music|theater|literature|creative|media/i,
      'social': /psychology|sociology|anthropology|political|social|history/i,
      'medical': /medicine|medical|nursing|health|pharmacy|dentistry/i,
      'law': /law|legal|jurisprudence/i,
      'education': /education|teaching|pedagogy/i
    };
    
    for (const [category, pattern] of Object.entries(categories)) {
      if (pattern.test(fieldLower)) {
        return category;
      }
    }
    
    return 'other';
  },
  
  /**
   * Calculate education duration
   * @param {string} startDate - Start date
   * @param {string} endDate - End date
   * @returns {number} Duration in years
   */
  calculateDuration(startDate, endDate) {
    if (!startDate) return 0;
    
    const start = parseInt(startDate);
    const end = endDate === 'Present' ? new Date().getFullYear() : parseInt(endDate);
    
    return end - start;
  },
  
  /**
   * Calculate total education years
   * @param {Array<Object>} education - Education items
   * @returns {number} Total years
   */
  calculateTotalEducationYears(education) {
    return education.reduce((total, item) => {
      return total + (item.duration || 0);
    }, 0);
  },
  
  /**
   * Check if education is recent (within 5 years)
   * @param {string} endDate - End date
   * @returns {boolean}
   */
  isRecent(endDate) {
    if (endDate === 'Present') return true;
    
    const year = parseInt(endDate);
    const currentYear = new Date().getFullYear();
    
    return (currentYear - year) <= 5;
  },
  
  /**
   * Extract unique fields of study
   * @param {Array<Object>} education - Education items
   * @returns {Array<string>} Fields
   */
  extractFieldsOfStudy(education) {
    const fields = new Set();
    
    education.forEach(item => {
      if (item.field) {
        fields.add(item.fieldCategory);
      }
    });
    
    return Array.from(fields);
  },
  
  /**
   * Summarize education for AI
   * @param {Array<Object>} education - Education items
   * @returns {string} Summary
   */
  summarizeEducation(education) {
    if (education.length === 0) return 'No education listed';
    
    const parts = [];
    
    education.forEach(item => {
      let summary = item.degree || 'Degree';
      if (item.field) summary += ` in ${item.field}`;
      summary += ` from ${item.school}`;
      if (item.endDate) summary += ` (${item.endDate})`;
      
      parts.push(summary);
    });
    
    return parts.join('; ');
  }
};


  /* ============================================
   * MODULE: extractors/recommendations.js
   * ============================================ */
/**
 * Recommendations Extractor Module for ElevateLI
 * Handles extraction of LinkedIn profile recommendations section
 * This module will be concatenated into analyzer.js for Manifest V3 compatibility
 */

const RecommendationsExtractor = {
  name: 'recommendations',
  
  selectors: [
    'section[data-section="recommendations"]',
    'section.pv-recommendations-section',
    'section#recommendations-section',
    '#recommendations',
    'div[id="recommendations"]',
    // New pattern: anchor + sibling
    '#recommendations.pv-profile-card__anchor + div',
    '#recommendations ~ div'
  ],
  
  /**
   * Quick scan for recommendations section existence
   * @returns {Object} Scan results
   */
  async scan() {
    const startTime = Date.now();
    
    Logger.info('[RecommendationsExtractor] Starting scan v2 - CUSTOM SECTION FINDER');
    
    // Custom section finding for recommendations - look for anchor and get the right sibling
    const anchor = document.querySelector('div#recommendations.pv-profile-card__anchor');
    let section = null;
    
    if (anchor) {
      Logger.info('[RecommendationsExtractor] Found recommendations anchor, checking siblings');
      let sibling = anchor.nextElementSibling;
      let siblingIndex = 0;
      
      while (sibling && siblingIndex < 5) {
        // Look for recommendations content indicators
        const showAllLink = sibling.querySelector('a[href*="/details/recommendations"]');
        const hasRecommendationTabs = sibling.querySelector('[aria-label*="received"], [aria-label*="given"]');
        const hasRecommendationItems = sibling.querySelectorAll('.pvs-list__paged-list-item, .artdeco-list__item, li').length > 0;
        const textContent = sibling.textContent || '';
        const hasRecommendationText = textContent.includes('recommendation') || textContent.includes('Received');
        
        Logger.info(`[RecommendationsExtractor] Sibling ${siblingIndex}: showAll: ${!!showAllLink}, tabs: ${!!hasRecommendationTabs}, items: ${hasRecommendationItems}, hasText: ${hasRecommendationText}`);
        
        // We want the sibling with actual recommendation content
        if ((showAllLink || hasRecommendationTabs || hasRecommendationItems) && hasRecommendationText) {
          section = sibling;
          Logger.info(`[RecommendationsExtractor] Found recommendations section at sibling ${siblingIndex}`);
          break;
        }
        
        sibling = sibling.nextElementSibling;
        siblingIndex++;
      }
    }
    
    // Fallback to BaseExtractor if custom method fails
    if (!section) {
      Logger.info('[RecommendationsExtractor] Custom section finder failed, using BaseExtractor');
      section = BaseExtractor.findSection(this.selectors, 'Recommendations');
    }
    
    const exists = !!section;
    
    if (section) {
      Logger.info(`[RecommendationsExtractor] Section found: ${exists}, tagName: ${section.tagName}, id: ${section.id || 'none'}, classes: ${section.className}`);
    } else {
      Logger.info('[RecommendationsExtractor] No section found');
    }
    
    let receivedCount = 0;
    let givenCount = 0;
    
    if (exists) {
      // Look for tabs or separate sections
      const buttons = section.querySelectorAll('button');
      const receivedTab = section.querySelector('[aria-label*="received"]') || 
                         Array.from(buttons).find(btn => 
                           btn.textContent && btn.textContent.includes('Received'));
      const givenTab = section.querySelector('[aria-label*="given"]') || 
                       Array.from(buttons).find(btn => 
                         btn.textContent && btn.textContent.includes('Given'));
      
      // Count visible recommendations with multiple selectors
      let recommendationItems = section.querySelectorAll('.pvs-list__paged-list-item, .artdeco-list__item');
      
      // Try additional selectors if none found
      if (recommendationItems.length === 0) {
        Logger.debug('[RecommendationsExtractor] No items with standard selectors, trying alternatives');
        recommendationItems = section.querySelectorAll('li[class*="pvs"], div[class*="entity"], li');
      }
      
      // Try to distinguish between received and given
      if (receivedTab && receivedTab.getAttribute('aria-selected') === 'true') {
        receivedCount = recommendationItems.length;
      } else if (givenTab && givenTab.getAttribute('aria-selected') === 'true') {
        givenCount = recommendationItems.length;
      } else {
        // Default to received if no tabs
        receivedCount = recommendationItems.length;
      }
      
      // First try to find recommendations count from show all link
      const showAllLink = section.querySelector('a[href*="/details/recommendations"]');
      if (showAllLink) {
        const linkText = showAllLink.textContent || '';
        Logger.info(`[RecommendationsExtractor] Found show all link with text: "${linkText}"`);
        
        // Try multiple patterns for extracting count
        const patterns = [
          /Show\s+all\s+(\d+)\s+recommendations?/i,
          /(\d+)\s+recommendations?/i,
          /All\s+(\d+)/i
        ];
        
        for (const pattern of patterns) {
          const match = linkText.match(pattern);
          if (match) {
            receivedCount = parseInt(match[1]);
            Logger.info(`[RecommendationsExtractor] Found count from show all link: ${receivedCount}`);
            break;
          }
        }
      }
      
      // Fallback to extractShowAllInfo
      if (receivedCount === 0) {
        const showAllInfo = BaseExtractor.extractShowAllInfo(section, 'recommendations');
        if (showAllInfo.totalCount > 0) {
          Logger.info(`[RecommendationsExtractor] Found total count from show all: ${showAllInfo.totalCount}`);
          receivedCount = showAllInfo.totalCount;
        }
      }
      
      // Last resort: Text pattern matching on page
      if (receivedCount === 0) {
        // First try section text
        const sectionText = section.innerText || '';
        Logger.info(`[RecommendationsExtractor] Searching section text (${sectionText.length} chars)`);
        
        const patterns = [
          /(\d+)\s*recommendations?\s*received/i,
          /Received\s*\((\d+)\)/i,
          /(\d+)\s*people\s*have\s*recommended/i
        ];
        
        for (const pattern of patterns) {
          const match = sectionText.match(pattern);
          if (match) {
            receivedCount = parseInt(match[1]);
            Logger.info(`[RecommendationsExtractor] Found count from section text pattern: ${receivedCount}`);
            break;
          }
        }
        
        // If still 0, try page text
        if (receivedCount === 0) {
          const pageText = document.body.innerText || '';
          for (const pattern of patterns) {
            const match = pageText.match(pattern);
            if (match) {
              receivedCount = parseInt(match[1]);
              Logger.info(`[RecommendationsExtractor] Found count from page text pattern: ${receivedCount}`);
              break;
            }
          }
        }
      }
    }
    
    Logger.info(`[RecommendationsExtractor] Scan completed in ${Date.now() - startTime}ms`, {
      exists,
      receivedCount,
      givenCount
    });
    
    return {
      exists,
      receivedCount,
      givenCount,
      hasRecommendations: receivedCount > 0 || givenCount > 0
    };
  },
  
  /**
   * Extract recommendations data for completeness scoring
   * @returns {Object} Basic recommendations data
   */
  async extract() {
    const startTime = Date.now();
    const scanResult = await this.scan();
    
    if (!scanResult.exists) {
      Logger.info('[RecommendationsExtractor] Recommendations section not found');
      return {
        exists: false,
        count: 0,
        receivedCount: 0,
        givenCount: 0
      };
    }
    
    // Use same custom section finder as scan
    const anchor = document.querySelector('div#recommendations.pv-profile-card__anchor');
    let section = null;
    
    if (anchor) {
      let sibling = anchor.nextElementSibling;
      let siblingIndex = 0;
      
      while (sibling && siblingIndex < 5) {
        const showAllLink = sibling.querySelector('a[href*="/details/recommendations"]');
        const hasRecommendationContent = sibling.textContent && sibling.textContent.includes('recommendation');
        
        if ((showAllLink || hasRecommendationContent) && sibling.querySelectorAll('li, .pvs-list__paged-list-item').length > 0) {
          section = sibling;
          break;
        }
        
        sibling = sibling.nextElementSibling;
        siblingIndex++;
      }
    }
    
    if (!section) {
      section = BaseExtractor.findSection(this.selectors, 'Recommendations');
    }
    
    // Try to get both received and given counts
    const counts = await this.extractRecommendationCounts(section);
    
    const result = {
      exists: true,
      count: counts.received + counts.given,
      receivedCount: counts.received,
      givenCount: counts.given,
      hasRecommendations: counts.received > 0,
      isActive: counts.given > 0, // Shows if user gives recommendations
      ratio: counts.received > 0 ? (counts.given / counts.received).toFixed(2) : 0
    };
    
    Logger.info(`[RecommendationsExtractor] Extracted ${result.count} recommendations (${result.receivedCount} received, ${result.givenCount} given) in ${Date.now() - startTime}ms`);
    
    return result;
  },
  
  /**
   * Deep extraction for AI analysis
   * @returns {Object} Detailed recommendations data
   */
  async extractDeep() {
    const startTime = Date.now();
    const basicData = await this.extract();
    
    if (!basicData.exists) return basicData;
    
    // Use same custom section finder
    const anchor = document.querySelector('div#recommendations.pv-profile-card__anchor');
    let section = null;
    
    if (anchor) {
      let sibling = anchor.nextElementSibling;
      let siblingIndex = 0;
      
      while (sibling && siblingIndex < 5) {
        const showAllLink = sibling.querySelector('a[href*="/details/recommendations"]');
        const hasRecommendationContent = sibling.textContent && sibling.textContent.includes('recommendation');
        
        if ((showAllLink || hasRecommendationContent) && sibling.querySelectorAll('li, .pvs-list__paged-list-item').length > 0) {
          section = sibling;
          break;
        }
        
        sibling = sibling.nextElementSibling;
        siblingIndex++;
      }
    }
    
    if (!section) {
      section = BaseExtractor.findSection(this.selectors, 'Recommendations');
    }
    
    // Extract detailed recommendations
    const received = await this.extractReceivedRecommendations(section);
    const given = await this.extractGivenRecommendations(section);
    
    const result = {
      ...basicData,
      received: received,
      given: given,
      
      // Analysis features
      recommenderRoles: this.extractRecommenderRoles(received),
      recommendationKeywords: this.extractKeywords(received),
      sentimentAnalysis: this.analyzeSentiments(received),
      relationshipTypes: this.categorizeRelationships(received),
      skillsMentioned: this.extractMentionedSkills(received),
      averageLength: this.calculateAverageLength(received),
      
      // Time analysis
      mostRecentDate: this.getMostRecentDate(received),
      isCurrentlyEndorsed: this.hasRecentRecommendations(received),
      
      // For AI processing
      recommendationChunks: this.prepareForAI(received)
    };
    
    Logger.info(`[RecommendationsExtractor] Deep extraction completed in ${Date.now() - startTime}ms`, {
      receivedDetails: received.length,
      givenDetails: given.length
    });
    
    return result;
  },
  
  /**
   * Extract recommendation counts
   * @param {Element} section - Recommendations section
   * @returns {Object} Counts
   */
  async extractRecommendationCounts(section) {
    const counts = { received: 0, given: 0 };
    
    // First try text pattern matching on the section
    const sectionText = section.innerText || '';
    const patterns = [
      /(\d+)\s*recommendations?\s*received/i,
      /Received\s*\((\d+)\)/i,
      /(\d+)\s*people\s*have\s*recommended/i
    ];
    
    for (const pattern of patterns) {
      const match = sectionText.match(pattern);
      if (match) {
        counts.received = parseInt(match[1]);
        Logger.info(`[RecommendationsExtractor] Found received count from text: ${counts.received}`);
        break;
      }
    }
    
    // Check for tab buttons with counts
    const tabSelectors = [
      'button[role="tab"]',
      '.artdeco-tabpanel button',
      '[aria-label*="received"]',
      '[aria-label*="given"]'
    ];
    
    for (const selector of tabSelectors) {
      const tabs = section.querySelectorAll(selector);
      tabs.forEach(tab => {
        const text = tab.textContent || tab.getAttribute('aria-label') || '';
        
        const receivedMatch = text.match(/received[^\d]*(\d+)/i);
        if (receivedMatch) {
          counts.received = parseInt(receivedMatch[1]);
        }
        
        const givenMatch = text.match(/given[^\d]*(\d+)/i);
        if (givenMatch) {
          counts.given = parseInt(givenMatch[1]);
        }
      });
    }
    
    // If no tabs found, count visible items as received
    if (counts.received === 0 && counts.given === 0) {
      const items = section.querySelectorAll('.pvs-list__paged-list-item, .artdeco-list__item');
      counts.received = items.length;
      
      // Also check extractShowAllInfo for total count
      const showAllInfo = BaseExtractor.extractShowAllInfo(section, 'recommendations');
      if (showAllInfo.totalCount > 0) {
        counts.received = Math.max(counts.received, showAllInfo.totalCount);
      }
    }
    
    return counts;
  },
  
  /**
   * Extract received recommendations
   * @param {Element} section - Recommendations section
   * @returns {Array<Object>} Received recommendations
   */
  async extractReceivedRecommendations(section) {
    const recommendations = [];
    
    // Click on received tab if exists
    const buttons = section.querySelectorAll('button');
    const receivedTab = section.querySelector('[aria-label*="received"]') || 
                       Array.from(buttons).find(btn => 
                         btn.textContent && btn.textContent.includes('Received'));
    if (receivedTab && receivedTab.getAttribute('aria-selected') !== 'true') {
      try {
        receivedTab.click();
        await new Promise(resolve => setTimeout(resolve, 1000));
      } catch (error) {
        Logger.warn('[RecommendationsExtractor] Failed to click received tab', error);
      }
    }
    
    // Extract recommendation items
    const items = section.querySelectorAll('.pvs-list__paged-list-item, .artdeco-list__item');
    
    for (const item of items) {
      const recommendation = await this.extractRecommendationItem(item);
      if (recommendation.recommenderName) {
        recommendations.push(recommendation);
      }
    }
    
    return recommendations;
  },
  
  /**
   * Extract given recommendations
   * @param {Element} section - Recommendations section
   * @returns {Array<Object>} Given recommendations
   */
  async extractGivenRecommendations(section) {
    const recommendations = [];
    
    // Click on given tab if exists
    const buttons = section.querySelectorAll('button');
    const givenTab = section.querySelector('[aria-label*="given"]') || 
                     Array.from(buttons).find(btn => 
                       btn.textContent && btn.textContent.includes('Given'));
    if (givenTab) {
      try {
        givenTab.click();
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // Extract items after tab switch
        const items = section.querySelectorAll('.pvs-list__paged-list-item, .artdeco-list__item');
        
        for (const item of items) {
          const recommendation = await this.extractRecommendationItem(item);
          if (recommendation.recommenderName) {
            recommendations.push(recommendation);
          }
        }
      } catch (error) {
        Logger.warn('[RecommendationsExtractor] Failed to extract given recommendations', error);
      }
    }
    
    return recommendations;
  },
  
  /**
   * Extract single recommendation item
   * @param {Element} element - Recommendation element
   * @returns {Object} Recommendation data
   */
  async extractRecommendationItem(element) {
    const recommendation = {
      recommenderName: '',
      recommenderTitle: '',
      relationship: '',
      text: '',
      date: ''
    };
    
    // Extract recommender name
    const nameEl = element.querySelector('.t-bold span[aria-hidden="true"], h3 span[aria-hidden="true"]');
    recommendation.recommenderName = BaseExtractor.extractTextContent(nameEl);
    
    // Extract recommender title and relationship
    const subtitleEl = element.querySelector('.t-14:not(.t-bold) span[aria-hidden="true"]');
    if (subtitleEl) {
      const subtitleText = BaseExtractor.extractTextContent(subtitleEl);
      // Parse "Title, Relationship, Date"
      const parts = subtitleText.split(',').map(p => p.trim());
      if (parts.length > 0) recommendation.recommenderTitle = parts[0];
      if (parts.length > 1) recommendation.relationship = parts[1];
      if (parts.length > 2) recommendation.date = parts[2];
    }
    
    // Extract recommendation text
    const textEl = element.querySelector('.pvs-list__outer-container span[aria-hidden="true"], .recommendation-text');
    recommendation.text = BaseExtractor.extractTextContent(textEl);
    
    return recommendation;
  },
  
  /**
   * Extract recommender roles/titles
   * @param {Array<Object>} recommendations - Recommendations
   * @returns {Array<string>} Unique roles
   */
  extractRecommenderRoles(recommendations) {
    const roles = new Set();
    
    recommendations.forEach(rec => {
      if (rec.recommenderTitle) {
        // Extract role from title (e.g., "Senior Developer at Company" -> "Senior Developer")
        const role = rec.recommenderTitle.split(' at ')[0].trim();
        roles.add(role);
      }
    });
    
    return Array.from(roles);
  },
  
  /**
   * Extract keywords from recommendations
   * @param {Array<Object>} recommendations - Recommendations
   * @returns {Array<string>} Keywords
   */
  extractKeywords(recommendations) {
    const keywords = {};
    const stopWords = new Set(['the', 'be', 'to', 'of', 'and', 'a', 'in', 'that', 'have', 'i', 'it', 'for', 'not', 'on', 'with', 'he', 'as', 'you', 'do', 'at']);
    
    recommendations.forEach(rec => {
      const words = rec.text.toLowerCase()
        .replace(/[^\w\s]/g, ' ')
        .split(/\s+/)
        .filter(word => word.length > 3 && !stopWords.has(word));
      
      words.forEach(word => {
        keywords[word] = (keywords[word] || 0) + 1;
      });
    });
    
    // Return top keywords
    return Object.entries(keywords)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 20)
      .map(([word]) => word);
  },
  
  /**
   * Analyze sentiments of recommendations
   * @param {Array<Object>} recommendations - Recommendations
   * @returns {Object} Sentiment analysis
   */
  analyzeSentiments(recommendations) {
    const sentiments = {
      positive: 0,
      neutral: 0,
      negative: 0
    };
    
    const positiveWords = ['excellent', 'outstanding', 'exceptional', 'great', 'amazing', 'brilliant', 'talented', 'skilled', 'professional', 'dedicated'];
    const negativeWords = ['difficult', 'challenging', 'issue', 'problem', 'concern'];
    
    recommendations.forEach(rec => {
      const text = rec.text.toLowerCase();
      let score = 0;
      
      positiveWords.forEach(word => {
        if (text.includes(word)) score++;
      });
      
      negativeWords.forEach(word => {
        if (text.includes(word)) score--;
      });
      
      if (score > 0) sentiments.positive++;
      else if (score < 0) sentiments.negative++;
      else sentiments.neutral++;
    });
    
    return sentiments;
  },
  
  /**
   * Categorize relationships
   * @param {Array<Object>} recommendations - Recommendations
   * @returns {Object} Relationship categories
   */
  categorizeRelationships(recommendations) {
    const categories = {
      manager: 0,
      colleague: 0,
      report: 0,
      client: 0,
      other: 0
    };
    
    recommendations.forEach(rec => {
      const rel = (rec.relationship || '').toLowerCase();
      
      if (rel.includes('managed') || rel.includes('reported')) {
        categories.manager++;
      } else if (rel.includes('worked with') || rel.includes('colleague')) {
        categories.colleague++;
      } else if (rel.includes('managed directly')) {
        categories.report++;
      } else if (rel.includes('client') || rel.includes('customer')) {
        categories.client++;
      } else {
        categories.other++;
      }
    });
    
    return categories;
  },
  
  /**
   * Extract mentioned skills
   * @param {Array<Object>} recommendations - Recommendations
   * @returns {Array<string>} Skills mentioned
   */
  extractMentionedSkills(recommendations) {
    const skills = new Set();
    
    const skillPatterns = [
      /\b(leadership|communication|teamwork|problem solving|analytical|technical|creative|strategic)\b/gi,
      /\b(programming|software|development|engineering|design|analysis|management)\b/gi,
      /\b(java|python|javascript|react|node|sql|aws|cloud|data)\b/gi
    ];
    
    recommendations.forEach(rec => {
      skillPatterns.forEach(pattern => {
        const matches = rec.text.match(pattern);
        if (matches) {
          matches.forEach(skill => skills.add(skill.toLowerCase()));
        }
      });
    });
    
    return Array.from(skills);
  },
  
  /**
   * Calculate average recommendation length
   * @param {Array<Object>} recommendations - Recommendations
   * @returns {number} Average length
   */
  calculateAverageLength(recommendations) {
    if (recommendations.length === 0) return 0;
    
    const totalLength = recommendations.reduce((sum, rec) => sum + rec.text.length, 0);
    return Math.round(totalLength / recommendations.length);
  },
  
  /**
   * Get most recent recommendation date
   * @param {Array<Object>} recommendations - Recommendations
   * @returns {string} Most recent date
   */
  getMostRecentDate(recommendations) {
    // This is simplified - would need proper date parsing
    return recommendations[0]?.date || 'Unknown';
  },
  
  /**
   * Check if has recent recommendations (within 2 years)
   * @param {Array<Object>} recommendations - Recommendations
   * @returns {boolean}
   */
  hasRecentRecommendations(recommendations) {
    // Simplified check - would need proper date parsing
    return recommendations.some(rec => {
      const date = rec.date || '';
      return date.includes('2024') || date.includes('2023');
    });
  },
  
  /**
   * Prepare recommendations for AI processing
   * @param {Array<Object>} recommendations - Recommendations
   * @returns {Array<Object>} Chunked recommendations
   */
  prepareForAI(recommendations) {
    return recommendations.map((rec, index) => ({
      index: index + 1,
      recommender: `${rec.recommenderName} (${rec.recommenderTitle})`,
      relationship: rec.relationship,
      text: BaseExtractor.chunkText(rec.text, 500),
      keywords: this.extractKeywords([rec])
    }));
  }
};


  /* ============================================
   * MODULE: extractors/certifications.js
   * ============================================ */
/**
 * Certifications Extractor Module for ElevateLI
 * Handles extraction of LinkedIn profile certifications section
 * This module will be concatenated into analyzer.js for Manifest V3 compatibility
 */

const CertificationsExtractor = {
  name: 'certifications',
  
  selectors: [
    'section[data-section="certifications"]',
    'section#licenses-and-certifications',
    'section#certifications',
    'div[id*="certifications"]',
    'section.pv-accomplishments-section',
    // New pattern: anchor + sibling
    '#licenses_and_certifications.pv-profile-card__anchor + div',
    '#certifications.pv-profile-card__anchor + div',
    '#licenses_and_certifications ~ div',
    '#certifications ~ div'
  ],
  
  /**
   * Quick scan for certifications section existence
   * @returns {Object} Scan results
   */
  async scan() {
    const startTime = Date.now();
    
    Logger.info('[CertificationsExtractor] Starting scan v2 - CUSTOM SECTION FINDER');
    
    // Custom section finding for certifications - check multiple anchor IDs
    let section = null;
    const anchorIds = ['licenses_and_certifications', 'certifications', 'licenses-and-certifications'];
    
    for (const anchorId of anchorIds) {
      const anchor = document.querySelector(`div#${anchorId}.pv-profile-card__anchor`);
      if (anchor) {
        Logger.info(`[CertificationsExtractor] Found certifications anchor with ID: #${anchorId}, checking siblings`);
        let sibling = anchor.nextElementSibling;
        let siblingIndex = 0;
        
        while (sibling && siblingIndex < 5) {
          // Look for certification content indicators
          const showAllLink = sibling.querySelector('a[href*="/details/certifications"], a[href*="/details/licenses"]');
          const hasCertificationItems = sibling.querySelectorAll('.pvs-list__paged-list-item, .artdeco-list__item, li').length > 0;
          const textContent = sibling.textContent || '';
          const hasCertificationText = textContent.includes('certification') || textContent.includes('Certification') || textContent.includes('license');
          
          Logger.info(`[CertificationsExtractor] Sibling ${siblingIndex}: showAll: ${!!showAllLink}, items: ${hasCertificationItems}, hasText: ${hasCertificationText}`);
          
          // We want the sibling with actual certification content
          if ((showAllLink || hasCertificationItems) && hasCertificationText) {
            section = sibling;
            Logger.info(`[CertificationsExtractor] Found certifications section at sibling ${siblingIndex}`);
            break;
          }
          
          sibling = sibling.nextElementSibling;
          siblingIndex++;
        }
        if (section) break;
      }
    }
    
    // Fallback to BaseExtractor if custom method fails
    if (!section) {
      Logger.info('[CertificationsExtractor] Custom section finder failed, using BaseExtractor');
      section = BaseExtractor.findSection(this.selectors, 'Certifications');
    }
    
    const exists = !!section;
    
    if (section) {
      Logger.info(`[CertificationsExtractor] Section found: ${exists}, tagName: ${section.tagName}, id: ${section.id || 'none'}, classes: ${section.className}`);
    } else {
      Logger.info('[CertificationsExtractor] No section found');
    }
    
    let visibleCount = 0;
    let totalCount = 0;
    if (exists) {
      let items = section.querySelectorAll('.pvs-list__paged-list-item, .artdeco-list__item');
      
      // Try additional selectors if none found
      if (items.length === 0) {
        Logger.debug('[CertificationsExtractor] No items with standard selectors, trying alternatives');
        items = section.querySelectorAll('li[class*="pvs"], div[class*="entity"], li');
      }
      
      visibleCount = items.length;
      
      // First try to find count from show all link
      const showAllLink = section.querySelector('a[href*="/details/certifications"], a[href*="/details/licenses"]');
      if (showAllLink) {
        const linkText = showAllLink.textContent || '';
        Logger.info(`[CertificationsExtractor] Found show all link with text: "${linkText}"`);
        
        // Try multiple patterns for extracting count
        const patterns = [
          /Show\s+all\s+(\d+)\s+certifications?/i,
          /Show\s+all\s+(\d+)\s+licenses?/i,
          /(\d+)\s+certifications?/i,
          /(\d+)\s+licenses?/i,
          /All\s+(\d+)/i
        ];
        
        for (const pattern of patterns) {
          const match = linkText.match(pattern);
          if (match) {
            totalCount = parseInt(match[1]);
            Logger.info(`[CertificationsExtractor] Found count from show all link: ${totalCount}`);
            break;
          }
        }
      }
      
      // Fallback to extractShowAllInfo if not found
      if (totalCount === 0) {
        const showAllInfo = BaseExtractor.extractShowAllInfo(section, 'certifications');
        totalCount = showAllInfo.totalCount || visibleCount;
      }
      
      Logger.info(`[CertificationsExtractor] Visible: ${visibleCount}, Total: ${totalCount}`);
    }
    
    Logger.info(`[CertificationsExtractor] Scan completed in ${Date.now() - startTime}ms`, {
      exists,
      visibleCount
    });
    
    return {
      exists,
      visibleCount,
      totalCount
    };
  },
  
  /**
   * Extract certifications data for completeness scoring
   * @returns {Object} Basic certifications data
   */
  async extract() {
    const startTime = Date.now();
    const scanResult = await this.scan();
    
    if (!scanResult.exists) {
      Logger.info('[CertificationsExtractor] Certifications section not found');
      return {
        exists: false,
        count: 0,
        certifications: []
      };
    }
    
    // Use same custom section finder as scan
    let section = null;
    const anchorIds = ['licenses_and_certifications', 'certifications', 'licenses-and-certifications'];
    
    for (const anchorId of anchorIds) {
      const anchor = document.querySelector(`div#${anchorId}.pv-profile-card__anchor`);
      if (anchor) {
        let sibling = anchor.nextElementSibling;
        let siblingIndex = 0;
        
        while (sibling && siblingIndex < 5) {
          const showAllLink = sibling.querySelector('a[href*="/details/certifications"], a[href*="/details/licenses"]');
          const hasCertificationContent = sibling.textContent && (sibling.textContent.includes('certification') || sibling.textContent.includes('license'));
          
          if ((showAllLink || hasCertificationContent) && sibling.querySelectorAll('li, .pvs-list__paged-list-item').length > 0) {
            section = sibling;
            break;
          }
          
          sibling = sibling.nextElementSibling;
          siblingIndex++;
        }
        if (section) break;
      }
    }
    
    if (!section) {
      section = BaseExtractor.findSection(this.selectors, 'Certifications');
    }
    const certifications = await this.extractCertificationItems(section);
    
    // Use total count from scan if available
    const totalCount = scanResult.totalCount || certifications.length;
    
    const result = {
      exists: true,
      count: totalCount,
      certifications: certifications.map(cert => ({
        name: cert.name,
        issuer: cert.issuer
      })),
      hasActiveCertifications: certifications.some(cert => !cert.expired),
      hasTechCertifications: certifications.some(cert => this.isTechnicalCertification(cert.name))
    };
    
    Logger.info(`[CertificationsExtractor] Extracted ${result.count} certifications in ${Date.now() - startTime}ms`);
    
    return result;
  },
  
  /**
   * Deep extraction for AI analysis
   * @returns {Object} Detailed certifications data
   */
  async extractDeep() {
    const startTime = Date.now();
    const basicData = await this.extract();
    
    if (!basicData.exists) return basicData;
    
    // Use same custom section finder
    let section = null;
    const anchorIds = ['licenses_and_certifications', 'certifications', 'licenses-and-certifications'];
    
    for (const anchorId of anchorIds) {
      const anchor = document.querySelector(`div#${anchorId}.pv-profile-card__anchor`);
      if (anchor) {
        let sibling = anchor.nextElementSibling;
        let siblingIndex = 0;
        
        while (sibling && siblingIndex < 5) {
          const showAllLink = sibling.querySelector('a[href*="/details/certifications"], a[href*="/details/licenses"]');
          const hasCertificationContent = sibling.textContent && (sibling.textContent.includes('certification') || sibling.textContent.includes('license'));
          
          if ((showAllLink || hasCertificationContent) && sibling.querySelectorAll('li, .pvs-list__paged-list-item').length > 0) {
            section = sibling;
            break;
          }
          
          sibling = sibling.nextElementSibling;
          siblingIndex++;
        }
        if (section) break;
      }
    }
    
    if (!section) {
      section = BaseExtractor.findSection(this.selectors, 'Certifications');
    }
    const detailedCertifications = await this.extractDetailedCertifications(section);
    
    const result = {
      ...basicData,
      certifications: detailedCertifications,
      
      // Analysis features
      certificationsByIssuer: this.groupByIssuer(detailedCertifications),
      certificationCategories: this.categorizeCertifications(detailedCertifications),
      recentCertifications: detailedCertifications.filter(cert => this.isRecent(cert.issueDate)),
      expiringCertifications: detailedCertifications.filter(cert => this.isExpiringSoon(cert.expirationDate)),
      
      // Metrics
      averageCertificationAge: this.calculateAverageAge(detailedCertifications),
      renewalRate: this.calculateRenewalRate(detailedCertifications),
      
      // For AI processing
      certificationSummary: this.summarizeCertifications(detailedCertifications)
    };
    
    Logger.info(`[CertificationsExtractor] Deep extraction completed in ${Date.now() - startTime}ms`);
    
    return result;
  },
  
  /**
   * Extract certification items
   * @param {Element} section - Certifications section
   * @returns {Array<Object>} Certification items
   */
  async extractCertificationItems(section) {
    const items = [];
    const itemElements = section.querySelectorAll('.pvs-list__paged-list-item, .artdeco-list__item');
    
    for (const element of itemElements) {
      const item = await this.extractCertificationItem(element);
      if (item.name) {
        items.push(item);
      }
    }
    
    return items;
  },
  
  /**
   * Extract single certification item
   * @param {Element} element - Certification element
   * @returns {Object} Certification data
   */
  async extractCertificationItem(element) {
    const certification = {
      name: '',
      issuer: '',
      issueDate: '',
      expirationDate: '',
      credentialId: '',
      credentialUrl: '',
      expired: false
    };
    
    // Extract certification name
    const nameEl = element.querySelector('.t-bold span[aria-hidden="true"], h3 span[aria-hidden="true"]');
    certification.name = BaseExtractor.extractTextContent(nameEl);
    
    // Extract issuer
    const issuerEl = element.querySelector('.t-14:not(.t-bold) span[aria-hidden="true"]');
    certification.issuer = BaseExtractor.extractTextContent(issuerEl);
    
    // Extract dates
    const dateEl = element.querySelector('.pvs-entity__caption-wrapper');
    const dateText = BaseExtractor.extractTextContent(dateEl);
    if (dateText) {
      // Parse "Issued Jan 2023 · Expires Jan 2025"
      const issuedMatch = dateText.match(/Issued\s+([A-Za-z]+\s+\d{4})/);
      if (issuedMatch) {
        certification.issueDate = issuedMatch[1];
      }
      
      const expiresMatch = dateText.match(/Expires?\s+([A-Za-z]+\s+\d{4})/);
      if (expiresMatch) {
        certification.expirationDate = expiresMatch[1];
        // Check if expired
        certification.expired = this.isExpired(expiresMatch[1]);
      }
      
      // No expiration date mentioned
      if (!expiresMatch && dateText.includes('No Expiration')) {
        certification.expirationDate = 'No Expiration';
      }
    }
    
    // Extract credential ID
    const credentialEl = element.querySelector('.pvs-list__outer-container');
    if (credentialEl) {
      const credentialText = BaseExtractor.extractTextContent(credentialEl);
      const idMatch = credentialText.match(/Credential ID[:\s]+([^\s]+)/i);
      if (idMatch) {
        certification.credentialId = idMatch[1];
      }
    }
    
    // Extract credential URL
    const linkEl = element.querySelector('a[href*="credential"]');
    if (linkEl) {
      certification.credentialUrl = linkEl.href;
    }
    
    return certification;
  },
  
  /**
   * Extract detailed certification information
   * @param {Element} section - Certifications section
   * @returns {Array<Object>} Detailed certifications
   */
  async extractDetailedCertifications(section) {
    const certifications = await this.extractCertificationItems(section);
    
    // Enhance with additional analysis
    return certifications.map(cert => ({
      ...cert,
      category: this.categorizeCertification(cert.name, cert.issuer),
      isActive: !cert.expired && cert.expirationDate !== 'No Expiration',
      yearsSinceIssue: this.calculateYearsSince(cert.issueDate),
      yearsUntilExpiration: this.calculateYearsUntil(cert.expirationDate)
    }));
  },
  
  /**
   * Check if certification is technical
   * @param {string} name - Certification name
   * @returns {boolean}
   */
  isTechnicalCertification(name) {
    const techPatterns = /\b(AWS|Azure|Google Cloud|GCP|Cisco|Microsoft|Oracle|VMware|CompTIA|Linux|Red Hat|Docker|Kubernetes|Certified.*Engineer|Certified.*Developer|Certified.*Architect)\b/i;
    return techPatterns.test(name);
  },
  
  /**
   * Check if date is expired
   * @param {string} dateStr - Date string
   * @returns {boolean}
   */
  isExpired(dateStr) {
    if (!dateStr || dateStr === 'No Expiration') return false;
    
    // Simple comparison - would need proper date parsing
    const currentYear = new Date().getFullYear();
    const year = parseInt(dateStr.match(/\d{4}/)?.[0] || '9999');
    
    return year < currentYear;
  },
  
  /**
   * Check if certification is recent (within 2 years)
   * @param {string} dateStr - Issue date
   * @returns {boolean}
   */
  isRecent(dateStr) {
    if (!dateStr) return false;
    
    const currentYear = new Date().getFullYear();
    const year = parseInt(dateStr.match(/\d{4}/)?.[0] || '0');
    
    return (currentYear - year) <= 2;
  },
  
  /**
   * Check if certification is expiring soon (within 6 months)
   * @param {string} dateStr - Expiration date
   * @returns {boolean}
   */
  isExpiringSoon(dateStr) {
    if (!dateStr || dateStr === 'No Expiration') return false;
    
    // Simplified check - would need proper date parsing
    const currentYear = new Date().getFullYear();
    const year = parseInt(dateStr.match(/\d{4}/)?.[0] || '9999');
    
    return year === currentYear || year === currentYear + 1;
  },
  
  /**
   * Categorize certification
   * @param {string} name - Certification name
   * @param {string} issuer - Issuer name
   * @returns {string} Category
   */
  categorizeCertification(name, issuer) {
    const categories = {
      'cloud': /AWS|Azure|Google Cloud|GCP|Cloud/i,
      'security': /Security|CISSP|CEH|CompTIA Security/i,
      'networking': /Cisco|CCNA|CCNP|Network/i,
      'projectManagement': /PMP|Agile|Scrum|PRINCE2/i,
      'database': /Oracle|SQL|Database|MongoDB/i,
      'programming': /Java|Python|JavaScript|Developer/i,
      'dataScience': /Data Science|Machine Learning|AI|Analytics/i,
      'devops': /DevOps|Docker|Kubernetes|Jenkins/i
    };
    
    const combined = `${name} ${issuer}`;
    
    for (const [category, pattern] of Object.entries(categories)) {
      if (pattern.test(combined)) {
        return category;
      }
    }
    
    return 'other';
  },
  
  /**
   * Group certifications by issuer
   * @param {Array<Object>} certifications - Certifications
   * @returns {Object} Grouped certifications
   */
  groupByIssuer(certifications) {
    const grouped = {};
    
    certifications.forEach(cert => {
      const issuer = cert.issuer || 'Unknown';
      if (!grouped[issuer]) {
        grouped[issuer] = [];
      }
      grouped[issuer].push(cert);
    });
    
    return grouped;
  },
  
  /**
   * Categorize all certifications
   * @param {Array<Object>} certifications - Certifications
   * @returns {Object} Categories with counts
   */
  categorizeCertifications(certifications) {
    const categories = {};
    
    certifications.forEach(cert => {
      const category = cert.category || 'other';
      categories[category] = (categories[category] || 0) + 1;
    });
    
    return categories;
  },
  
  /**
   * Calculate years since issue
   * @param {string} dateStr - Issue date
   * @returns {number} Years
   */
  calculateYearsSince(dateStr) {
    if (!dateStr) return 0;
    
    const currentYear = new Date().getFullYear();
    const year = parseInt(dateStr.match(/\d{4}/)?.[0] || currentYear);
    
    return currentYear - year;
  },
  
  /**
   * Calculate years until expiration
   * @param {string} dateStr - Expiration date
   * @returns {number} Years
   */
  calculateYearsUntil(dateStr) {
    if (!dateStr || dateStr === 'No Expiration') return 999;
    
    const currentYear = new Date().getFullYear();
    const year = parseInt(dateStr.match(/\d{4}/)?.[0] || currentYear);
    
    return year - currentYear;
  },
  
  /**
   * Calculate average certification age
   * @param {Array<Object>} certifications - Certifications
   * @returns {number} Average age in years
   */
  calculateAverageAge(certifications) {
    if (certifications.length === 0) return 0;
    
    const totalAge = certifications.reduce((sum, cert) => {
      return sum + (cert.yearsSinceIssue || 0);
    }, 0);
    
    return Math.round(totalAge / certifications.length);
  },
  
  /**
   * Calculate renewal rate
   * @param {Array<Object>} certifications - Certifications
   * @returns {number} Renewal rate percentage
   */
  calculateRenewalRate(certifications) {
    const withExpiration = certifications.filter(cert => 
      cert.expirationDate && cert.expirationDate !== 'No Expiration'
    );
    
    if (withExpiration.length === 0) return 100;
    
    const active = withExpiration.filter(cert => !cert.expired).length;
    
    return Math.round((active / withExpiration.length) * 100);
  },
  
  /**
   * Summarize certifications for AI
   * @param {Array<Object>} certifications - Certifications
   * @returns {string} Summary
   */
  summarizeCertifications(certifications) {
    if (certifications.length === 0) return 'No certifications listed';
    
    const parts = [];
    const byCategory = {};
    
    certifications.forEach(cert => {
      const category = cert.category || 'other';
      if (!byCategory[category]) {
        byCategory[category] = [];
      }
      byCategory[category].push(cert);
    });
    
    Object.entries(byCategory).forEach(([category, certs]) => {
      parts.push(`${category}: ${certs.map(c => c.name).join(', ')}`);
    });
    
    return parts.join('; ');
  }
};


  /* ============================================
   * MODULE: extractors/projects.js
   * ============================================ */
/**
 * Projects Extractor Module for ElevateLI
 * Handles extraction of LinkedIn profile projects section
 * This module will be concatenated into analyzer.js for Manifest V3 compatibility
 */

const ProjectsExtractor = {
  name: 'projects',
  
  selectors: [
    'section[data-section="projects"]',
    'section:has(h2:contains("Projects"))',
    'div[data-view-name="profile-card"]:has(h2:contains("Projects"))',
    'section.pv-accomplishments-section:has(h3:contains("Project"))',
    'section#projects-section'
  ],
  
  /**
   * Quick scan for projects section existence
   * @returns {Object} Scan results
   */
  async scan() {
    const startTime = Date.now();
    
    const section = BaseExtractor.findSection(this.selectors, 'Projects');
    const exists = !!section;
    
    let visibleCount = 0;
    if (exists) {
      const items = section.querySelectorAll('.pvs-list__paged-list-item, .artdeco-list__item');
      visibleCount = items.length;
    }
    
    Logger.debug(`[ProjectsExtractor] Scan completed in ${Date.now() - startTime}ms`, {
      exists,
      visibleCount
    });
    
    return {
      exists,
      visibleCount
    };
  },
  
  /**
   * Extract projects data for completeness scoring
   * @returns {Object} Basic projects data
   */
  async extract() {
    const startTime = Date.now();
    const scanResult = await this.scan();
    
    if (!scanResult.exists) {
      Logger.info('[ProjectsExtractor] Projects section not found');
      return {
        exists: false,
        count: 0,
        projects: []
      };
    }
    
    const section = BaseExtractor.findSection(this.selectors, 'Projects');
    const projects = await this.extractProjectItems(section);
    
    const result = {
      exists: true,
      count: projects.length,
      projects: projects.map(proj => ({
        name: proj.name,
        hasDescription: proj.description.length > 0
      })),
      hasTechnicalProjects: projects.some(proj => this.isTechnicalProject(proj)),
      hasRecentProjects: projects.some(proj => this.isRecentProject(proj.date))
    };
    
    Logger.info(`[ProjectsExtractor] Extracted ${result.count} projects in ${Date.now() - startTime}ms`);
    
    return result;
  },
  
  /**
   * Deep extraction for AI analysis
   * @returns {Object} Detailed projects data
   */
  async extractDeep() {
    const startTime = Date.now();
    const basicData = await this.extract();
    
    if (!basicData.exists) return basicData;
    
    const section = BaseExtractor.findSection(this.selectors, 'Projects');
    const detailedProjects = await this.extractDetailedProjects(section);
    
    const result = {
      ...basicData,
      projects: detailedProjects,
      
      // Analysis features
      projectCategories: this.categorizeProjects(detailedProjects),
      technologiesUsed: this.extractTechnologies(detailedProjects),
      projectTypes: this.classifyProjectTypes(detailedProjects),
      collaborativeProjects: detailedProjects.filter(p => p.hasCollaborators),
      
      // Metrics
      averageDescriptionLength: this.calculateAverageDescriptionLength(detailedProjects),
      projectsWithLinks: detailedProjects.filter(p => p.projectUrl).length,
      
      // For AI processing
      projectSummaries: this.prepareForAI(detailedProjects)
    };
    
    Logger.info(`[ProjectsExtractor] Deep extraction completed in ${Date.now() - startTime}ms`);
    
    return result;
  },
  
  /**
   * Extract project items
   * @param {Element} section - Projects section
   * @returns {Array<Object>} Project items
   */
  async extractProjectItems(section) {
    const items = [];
    const itemElements = section.querySelectorAll('.pvs-list__paged-list-item, .artdeco-list__item');
    
    for (const element of itemElements) {
      const item = await this.extractProjectItem(element);
      if (item.name) {
        items.push(item);
      }
    }
    
    return items;
  },
  
  /**
   * Extract single project item
   * @param {Element} element - Project element
   * @returns {Object} Project data
   */
  async extractProjectItem(element) {
    const project = {
      name: '',
      description: '',
      date: '',
      collaborators: [],
      projectUrl: '',
      technologies: []
    };
    
    // Extract project name
    const nameEl = element.querySelector('.t-bold span[aria-hidden="true"], h3 span[aria-hidden="true"]');
    project.name = BaseExtractor.extractTextContent(nameEl);
    
    // Extract date
    const dateEl = element.querySelector('.t-14:not(.t-bold) span[aria-hidden="true"]');
    project.date = BaseExtractor.extractTextContent(dateEl);
    
    // Extract description
    const descEl = element.querySelector('.pvs-list__outer-container span[aria-hidden="true"], .inline-show-more-text span[aria-hidden="true"]');
    project.description = BaseExtractor.extractTextContent(descEl);
    
    // Extract project URL
    const linkEl = element.querySelector('a[href*="project"], a[aria-label*="project"]');
    if (linkEl) {
      project.projectUrl = linkEl.href;
    }
    
    // Extract collaborators (if mentioned)
    const collaboratorText = project.description.match(/collaborated with|team of|worked with/i);
    if (collaboratorText) {
      project.hasCollaborators = true;
    }
    
    return project;
  },
  
  /**
   * Extract detailed project information
   * @param {Element} section - Projects section
   * @returns {Array<Object>} Detailed projects
   */
  async extractDetailedProjects(section) {
    const projects = await this.extractProjectItems(section);
    
    // Enhance with additional analysis
    return projects.map(proj => ({
      ...proj,
      technologies: this.extractProjectTechnologies(proj),
      category: this.categorizeProject(proj),
      type: this.classifyProjectType(proj),
      hasCollaborators: proj.hasCollaborators || this.detectCollaboration(proj.description),
      complexity: this.assessComplexity(proj),
      keywords: this.extractKeywords(proj)
    }));
  },
  
  /**
   * Check if project is technical
   * @param {Object} project - Project data
   * @returns {boolean}
   */
  isTechnicalProject(project) {
    const techIndicators = /\b(software|application|website|app|system|platform|tool|api|database|algorithm|machine learning|AI|data)\b/i;
    return techIndicators.test(project.name + ' ' + project.description);
  },
  
  /**
   * Check if project is recent
   * @param {string} dateStr - Project date
   * @returns {boolean}
   */
  isRecentProject(dateStr) {
    if (!dateStr) return false;
    
    const currentYear = new Date().getFullYear();
    const yearMatch = dateStr.match(/\d{4}/);
    
    if (yearMatch) {
      const year = parseInt(yearMatch[0]);
      return (currentYear - year) <= 2;
    }
    
    return false;
  },
  
  /**
   * Extract technologies from project
   * @param {Object} project - Project data
   * @returns {Array<string>} Technologies
   */
  extractProjectTechnologies(project) {
    const technologies = new Set();
    
    const techPatterns = [
      /\b(JavaScript|TypeScript|Python|Java|C\+\+|C#|Ruby|Go|Rust|PHP|Swift)\b/gi,
      /\b(React|Angular|Vue|Node\.js|Express|Django|Spring|Rails)\b/gi,
      /\b(AWS|Azure|GCP|Docker|Kubernetes|Jenkins|Git)\b/gi,
      /\b(MongoDB|PostgreSQL|MySQL|Redis|Elasticsearch)\b/gi,
      /\b(TensorFlow|PyTorch|Scikit-learn|Pandas|NumPy)\b/gi
    ];
    
    const searchText = project.name + ' ' + project.description;
    
    techPatterns.forEach(pattern => {
      const matches = searchText.match(pattern);
      if (matches) {
        matches.forEach(tech => technologies.add(tech));
      }
    });
    
    return Array.from(technologies);
  },
  
  /**
   * Categorize project
   * @param {Object} project - Project data
   * @returns {string} Category
   */
  categorizeProject(project) {
    const searchText = (project.name + ' ' + project.description).toLowerCase();
    
    const categories = {
      'web': /website|web app|frontend|backend|full stack/i,
      'mobile': /mobile|android|ios|app/i,
      'data': /data|analytics|visualization|dashboard|report/i,
      'ml': /machine learning|ml|ai|artificial intelligence|neural/i,
      'automation': /automation|script|bot|workflow/i,
      'opensource': /open source|github|contribution/i,
      'research': /research|study|analysis|paper/i
    };
    
    for (const [category, pattern] of Object.entries(categories)) {
      if (pattern.test(searchText)) {
        return category;
      }
    }
    
    return 'other';
  },
  
  /**
   * Classify project type
   * @param {Object} project - Project data
   * @returns {string} Type
   */
  classifyProjectType(project) {
    const searchText = (project.name + ' ' + project.description).toLowerCase();
    
    if (/personal|hobby|side/i.test(searchText)) return 'personal';
    if (/academic|university|course|school/i.test(searchText)) return 'academic';
    if (/work|professional|company|client/i.test(searchText)) return 'professional';
    if (/volunteer|nonprofit|charity/i.test(searchText)) return 'volunteer';
    
    return 'unspecified';
  },
  
  /**
   * Detect collaboration
   * @param {string} description - Project description
   * @returns {boolean}
   */
  detectCollaboration(description) {
    const collaborationIndicators = /\b(team|collaborated|worked with|group|together|we|our)\b/i;
    return collaborationIndicators.test(description);
  },
  
  /**
   * Assess project complexity
   * @param {Object} project - Project data
   * @returns {string} Complexity level
   */
  assessComplexity(project) {
    let score = 0;
    
    // Length of description
    if (project.description.length > 500) score += 2;
    else if (project.description.length > 200) score += 1;
    
    // Number of technologies
    if (project.technologies.length > 5) score += 2;
    else if (project.technologies.length > 2) score += 1;
    
    // Collaboration
    if (project.hasCollaborators) score += 1;
    
    // Technical indicators
    if (/architecture|system design|scalable|distributed/i.test(project.description)) score += 2;
    
    if (score >= 5) return 'complex';
    if (score >= 3) return 'moderate';
    return 'simple';
  },
  
  /**
   * Extract keywords from project
   * @param {Object} project - Project data
   * @returns {Array<string>} Keywords
   */
  extractKeywords(project) {
    const stopWords = new Set(['the', 'be', 'to', 'of', 'and', 'a', 'in', 'that', 'have', 'i']);
    
    const words = (project.name + ' ' + project.description)
      .toLowerCase()
      .replace(/[^\w\s]/g, ' ')
      .split(/\s+/)
      .filter(word => word.length > 3 && !stopWords.has(word));
    
    // Count frequency
    const frequency = {};
    words.forEach(word => {
      frequency[word] = (frequency[word] || 0) + 1;
    });
    
    // Return top keywords
    return Object.entries(frequency)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10)
      .map(([word]) => word);
  },
  
  /**
   * Categorize all projects
   * @param {Array<Object>} projects - Projects
   * @returns {Object} Categories with counts
   */
  categorizeProjects(projects) {
    const categories = {};
    
    projects.forEach(proj => {
      const category = proj.category || 'other';
      categories[category] = (categories[category] || 0) + 1;
    });
    
    return categories;
  },
  
  /**
   * Extract all technologies
   * @param {Array<Object>} projects - Projects
   * @returns {Array<string>} All unique technologies
   */
  extractTechnologies(projects) {
    const allTech = new Set();
    
    projects.forEach(proj => {
      (proj.technologies || []).forEach(tech => allTech.add(tech));
    });
    
    return Array.from(allTech);
  },
  
  /**
   * Classify all project types
   * @param {Array<Object>} projects - Projects
   * @returns {Object} Types with counts
   */
  classifyProjectTypes(projects) {
    const types = {};
    
    projects.forEach(proj => {
      const type = proj.type || 'unspecified';
      types[type] = (types[type] || 0) + 1;
    });
    
    return types;
  },
  
  /**
   * Calculate average description length
   * @param {Array<Object>} projects - Projects
   * @returns {number} Average length
   */
  calculateAverageDescriptionLength(projects) {
    if (projects.length === 0) return 0;
    
    const totalLength = projects.reduce((sum, proj) => sum + proj.description.length, 0);
    return Math.round(totalLength / projects.length);
  },
  
  /**
   * Prepare projects for AI processing
   * @param {Array<Object>} projects - Projects
   * @returns {Array<Object>} Prepared projects
   */
  prepareForAI(projects) {
    return projects.map((proj, index) => ({
      index: index + 1,
      name: proj.name,
      category: proj.category,
      type: proj.type,
      technologies: proj.technologies.join(', '),
      complexity: proj.complexity,
      description: BaseExtractor.chunkText(proj.description, 500),
      keywords: proj.keywords.slice(0, 5)
    }));
  }
};


  /* ============================================
   * MODULE: extractors/featured.js
   * ============================================ */
/**
 * Featured Extractor Module for ElevateLI
 * Handles extraction of LinkedIn profile featured section
 * This module will be concatenated into analyzer.js for Manifest V3 compatibility
 */

const FeaturedExtractor = {
  name: 'featured',
  
  selectors: [
    'section[data-section="featured"]',
    'section:has(h2:contains("Featured"))',
    'div[data-view-name="profile-card"]:has(h2:contains("Featured"))',
    'section.pv-profile-section:has(.pv-featured-container)',
    'section#featured-section'
  ],
  
  /**
   * Quick scan for featured section existence
   * @returns {Object} Scan results
   */
  async scan() {
    const startTime = Date.now();
    
    const section = BaseExtractor.findSection(this.selectors, 'Featured');
    const exists = !!section;
    
    let itemCount = 0;
    if (exists) {
      // Count featured items (posts, articles, media)
      const items = section.querySelectorAll('.pvs-list__paged-list-item, .artdeco-list__item, .pv-featured-container__item');
      itemCount = items.length;
    }
    
    Logger.debug(`[FeaturedExtractor] Scan completed in ${Date.now() - startTime}ms`, {
      exists,
      itemCount
    });
    
    return {
      exists,
      itemCount
    };
  },
  
  /**
   * Extract featured data for completeness scoring
   * @returns {Object} Basic featured data
   */
  async extract() {
    const startTime = Date.now();
    const scanResult = await this.scan();
    
    if (!scanResult.exists) {
      Logger.info('[FeaturedExtractor] Featured section not found');
      return {
        exists: false,
        count: 0,
        hasContent: false
      };
    }
    
    const result = {
      exists: true,
      count: scanResult.itemCount,
      hasContent: scanResult.itemCount > 0
    };
    
    Logger.info(`[FeaturedExtractor] Extracted ${result.count} featured items in ${Date.now() - startTime}ms`);
    
    return result;
  },
  
  /**
   * Deep extraction for AI analysis
   * @returns {Object} Detailed featured data
   */
  async extractDeep() {
    const startTime = Date.now();
    const basicData = await this.extract();
    
    if (!basicData.exists || basicData.count === 0) return basicData;
    
    const section = BaseExtractor.findSection(this.selectors, 'Featured');
    const featuredItems = await this.extractFeaturedItems(section);
    
    const result = {
      ...basicData,
      items: featuredItems,
      
      // Analysis features
      itemTypes: this.categorizeItems(featuredItems),
      hasExternalContent: featuredItems.some(item => item.isExternal),
      hasRecentContent: featuredItems.some(item => this.isRecent(item.date)),
      
      // For AI processing
      featuredSummary: this.summarizeFeatured(featuredItems)
    };
    
    Logger.info(`[FeaturedExtractor] Deep extraction completed in ${Date.now() - startTime}ms`);
    
    return result;
  },
  
  /**
   * Extract featured items
   * @param {Element} section - Featured section
   * @returns {Array<Object>} Featured items
   */
  async extractFeaturedItems(section) {
    const items = [];
    const itemElements = section.querySelectorAll('.pvs-list__paged-list-item, .artdeco-list__item');
    
    for (const element of itemElements) {
      const item = await this.extractFeaturedItem(element);
      if (item.title || item.type) {
        items.push(item);
      }
    }
    
    return items;
  },
  
  /**
   * Extract single featured item
   * @param {Element} element - Featured item element
   * @returns {Object} Featured item data
   */
  async extractFeaturedItem(element) {
    const item = {
      title: '',
      type: 'unknown',
      description: '',
      url: '',
      date: '',
      isExternal: false
    };
    
    // Extract title
    const titleEl = element.querySelector('.t-bold span[aria-hidden="true"], h3 span[aria-hidden="true"]');
    item.title = BaseExtractor.extractTextContent(titleEl);
    
    // Extract type (post, article, media, etc.)
    const typeEl = element.querySelector('.t-12, .pv-featured-container__label');
    const typeText = BaseExtractor.extractTextContent(typeEl);
    item.type = this.determineItemType(typeText, item.title);
    
    // Extract description
    const descEl = element.querySelector('.t-14 span[aria-hidden="true"]');
    item.description = BaseExtractor.extractTextContent(descEl);
    
    // Extract URL
    const linkEl = element.querySelector('a[href]');
    if (linkEl) {
      item.url = linkEl.href;
      item.isExternal = !item.url.includes('linkedin.com');
    }
    
    // Extract date if available
    const dateEl = element.querySelector('.t-black--light');
    item.date = BaseExtractor.extractTextContent(dateEl);
    
    return item;
  },
  
  /**
   * Determine item type
   * @param {string} typeText - Type text from element
   * @param {string} title - Item title
   * @returns {string} Item type
   */
  determineItemType(typeText, title) {
    const text = (typeText + ' ' + title).toLowerCase();
    
    if (text.includes('post')) return 'post';
    if (text.includes('article')) return 'article';
    if (text.includes('video')) return 'video';
    if (text.includes('document')) return 'document';
    if (text.includes('link')) return 'link';
    if (text.includes('media')) return 'media';
    
    return 'other';
  },
  
  /**
   * Categorize featured items
   * @param {Array<Object>} items - Featured items
   * @returns {Object} Item types with counts
   */
  categorizeItems(items) {
    const types = {};
    
    items.forEach(item => {
      types[item.type] = (types[item.type] || 0) + 1;
    });
    
    return types;
  },
  
  /**
   * Check if item is recent
   * @param {string} dateStr - Date string
   * @returns {boolean}
   */
  isRecent(dateStr) {
    if (!dateStr) return false;
    
    // Simple check for recent keywords
    const recentIndicators = /today|yesterday|day ago|week ago|month ago/i;
    return recentIndicators.test(dateStr);
  },
  
  /**
   * Summarize featured items for AI
   * @param {Array<Object>} items - Featured items
   * @returns {string} Summary
   */
  summarizeFeatured(items) {
    if (items.length === 0) return 'No featured content';
    
    const typeGroups = {};
    items.forEach(item => {
      if (!typeGroups[item.type]) {
        typeGroups[item.type] = [];
      }
      typeGroups[item.type].push(item.title || 'Untitled');
    });
    
    const parts = [];
    Object.entries(typeGroups).forEach(([type, titles]) => {
      parts.push(`${type}s: ${titles.length} items`);
    });
    
    return parts.join(', ');
  }
};


  /* ============================================
   * MODULE: scoring/completeness-scorer.js
   * ============================================ */
/**
 * Completeness Scorer Module for ElevateLI
 * Calculates profile completeness score based on section data
 * This module will be concatenated into analyzer.js for Manifest V3 compatibility
 */

class ProfileCompletenessCalculator {
  constructor() {
    // Section weights (total = 100)
    this.weights = {
      photo: 5,
      headline: 10,
      about: 20,
      experience: 25,
      skills: 15,
      education: 10,
      recommendations: 10,
      certifications: 3,
      projects: 2
    };
    
    // Section-specific rules
    this.rules = {
      photo: {
        check: (data) => data.exists || data === true,
        points: 5,
        getMessage: () => "Add a professional photo"
      },
      
      headline: {
        check: (data) => data.charCount >= 50,
        points: 10,
        getMessage: (data) => {
          if (!data.exists) return "Add a professional headline";
          if (data.charCount < 30) return "Expand your headline (minimum 50 characters)";
          if (data.isGeneric) return "Make your headline more specific and value-focused";
          return "Optimize your headline with keywords";
        }
      },
      
      about: {
        check: (data) => data.charCount >= 800,
        points: 20,
        getMessage: (data) => {
          if (!data.exists || data.charCount === 0) return "Add an About section";
          if (data.charCount < 400) return "Expand your About section (aim for 800+ characters)";
          if (data.charCount < 800) return "Add more detail to your About section";
          return "Enhance your About section";
        }
      },
      
      experience: {
        check: (data) => data.count >= 2,
        points: 25,
        getMessage: (data) => {
          if (!data.exists || data.count === 0) return "Add your work experience";
          if (data.count === 1) return "Add more work experiences (at least 2)";
          if (!data.hasCurrentRole) return "Update with your current position";
          return "Enhance experience descriptions";
        }
      },
      
      skills: {
        check: (data) => data.count >= 15,
        points: 15,
        getMessage: (data) => {
          if (!data.exists || data.count === 0) return "Add relevant skills";
          if (data.count < 5) return "Add more skills (aim for 15+)";
          if (data.count < 15) return `Add ${15 - data.count} more skills`;
          return "Optimize your skills section";
        }
      },
      
      education: {
        check: (data) => data.count >= 1,
        points: 10,
        getMessage: (data) => {
          if (!data.exists || data.count === 0) return "Add your education";
          return "Complete your education details";
        }
      },
      
      recommendations: {
        check: (data) => data.count >= 1,
        points: 10,
        getMessage: (data) => {
          if (!data.exists || data.count === 0) return "Request at least one recommendation";
          if (data.count < 3) return "Request more recommendations (aim for 3+)";
          return "Request recent recommendations";
        }
      },
      
      certifications: {
        check: (data) => data.count >= 1,
        points: 3,
        getMessage: () => "Add relevant certifications"
      },
      
      projects: {
        check: (data) => data.count >= 1,
        points: 2,
        getMessage: () => "Showcase projects you've worked on"
      }
    };
  }
  
  /**
   * Calculate completeness for all sections
   * @param {Object} sectionData - Data for all sections
   * @returns {Object} Complete scoring result
   */
  calculate(sectionData) {
    const startTime = Date.now();
    const breakdown = {};
    const recommendations = [];
    let earnedPoints = 0;
    let totalPoints = 0;
    
    // Process each section
    for (const [section, weight] of Object.entries(this.weights)) {
      const data = sectionData[section];
      const rule = this.rules[section];
      
      totalPoints += weight;
      
      if (rule && data !== undefined) {
        const passed = rule.check(data);
        const points = passed ? weight : 0;
        earnedPoints += points;
        
        breakdown[section] = {
          weight,
          earned: points,
          passed,
          data: this.summarizeData(data)
        };
        
        if (!passed) {
          recommendations.push({
            section,
            priority: this.getPriority(section, weight),
            message: rule.getMessage(data),
            impact: weight,
            weight: weight
          });
        }
      } else {
        // Section not found or no rule
        breakdown[section] = {
          weight,
          earned: 0,
          passed: false,
          data: null
        };
        
        recommendations.push({
          section,
          priority: 'high',
          message: `Add ${section} section`,
          impact: weight,
          weight: weight
        });
      }
    }
    
    // Sort recommendations by impact
    recommendations.sort((a, b) => b.impact - a.impact);
    
    const percentage = Math.round((earnedPoints / totalPoints) * 100);
    
    Logger.info(`[ProfileCompletenessCalculator] Calculated in ${Date.now() - startTime}ms`);
    
    return {
      score: percentage,
      earnedPoints,
      totalPoints,
      breakdown,
      recommendations: recommendations.slice(0, 5), // Top 5 recommendations
      allRecommendations: recommendations,
      isOptimized: percentage >= 85,
      level: this.getLevel(percentage)
    };
  }
  
  /**
   * Calculate section-specific completeness
   * @param {string} section - Section name
   * @param {Object} data - Section data
   * @returns {Object} Section score
   */
  scoreSection(section, data) {
    const weight = this.weights[section];
    const rule = this.rules[section];
    
    if (!weight || !rule) {
      return {
        score: 0,
        maxScore: 0,
        percentage: 0,
        passed: false
      };
    }
    
    const passed = rule.check(data);
    const score = passed ? weight : 0;
    
    return {
      score,
      maxScore: weight,
      percentage: passed ? 100 : 0,
      passed,
      recommendation: !passed ? rule.getMessage(data) : null
    };
  }
  
  /**
   * Get priority level for a section
   * @param {string} section - Section name
   * @param {number} weight - Section weight
   * @returns {string} Priority level
   */
  getPriority(section, weight) {
    if (weight >= 20) return 'critical';
    if (weight >= 10) return 'high';
    if (weight >= 5) return 'medium';
    return 'low';
  }
  
  /**
   * Get completeness level
   * @param {number} percentage - Completeness percentage
   * @returns {string} Level name
   */
  getLevel(percentage) {
    if (percentage >= 90) return 'excellent';
    if (percentage >= 75) return 'good';
    if (percentage >= 60) return 'fair';
    if (percentage >= 40) return 'needs_work';
    return 'poor';
  }
  
  /**
   * Summarize section data for storage
   * @param {Object} data - Section data
   * @returns {Object} Summary
   */
  summarizeData(data) {
    if (!data) return null;
    
    return {
      exists: data.exists || false,
      count: data.count || 0,
      charCount: data.charCount || 0,
      hasContent: data && (data.exists || data.count > 0 || data.charCount > 0)
    };
  }
  
  /**
   * Get actionable recommendations
   * @param {Object} scoringResult - Complete scoring result
   * @param {Object} settings - User settings
   * @returns {Array<Object>} Prioritized recommendations
   */
  getActionableRecommendations(scoringResult, settings = {}) {
    const { targetRole, seniorityLevel } = settings;
    const recommendations = [...scoringResult.allRecommendations];
    
    // Adjust priorities based on target role
    if (targetRole) {
      recommendations.forEach(rec => {
        // Boost skills for technical roles
        if (targetRole.includes('engineer') && rec.section === 'skills') {
          rec.priority = 'critical';
        }
        // Boost experience for senior roles
        if (seniorityLevel === 'senior' && rec.section === 'experience') {
          rec.priority = 'critical';
        }
      });
    }
    
    // Group by priority
    const grouped = {
      critical: [],
      high: [],
      medium: [],
      low: []
    };
    
    recommendations.forEach(rec => {
      grouped[rec.priority].push(rec);
    });
    
    // Return top recommendations from each priority level
    return [
      ...grouped.critical.slice(0, 2),
      ...grouped.high.slice(0, 2),
      ...grouped.medium.slice(0, 1)
    ];
  }
}


  /* ============================================
   * MODULE: scoring/quality-scorer.js
   * ============================================ */
/**
 * Quality Scorer Module for ElevateLI
 * Prepares data for AI analysis and processes AI responses
 * This module will be concatenated into analyzer.js for Manifest V3 compatibility
 */

const QualityScorer = {
  // Section weights for final score calculation
  weights: {
    photo: 0.05,      // 5%
    headline: 0.10,   // 10%
    about: 0.30,      // 30%
    experience: 0.30, // 30%
    skills: 0.15,     // 15%
    education: 0.05,  // 5%
    other: 0.05       // 5% (recommendations, certifications, projects)
  },
  
  /**
   * Prepare profile data for AI analysis
   * @param {Object} profileData - Extracted profile data
   * @param {Object} settings - User settings
   * @param {Object} completenessResult - Completeness scoring result
   * @returns {Object} Prepared data for AI
   */
  prepareForAI(profileData, settings, completenessResult) {
    Logger.info('[QualityScorer] Preparing data for AI analysis');
    
    const prepared = {
      // Meta information
      targetRole: settings.targetRole || 'general professional',
      seniorityLevel: settings.seniorityLevel || 'mid-level',
      customInstructions: settings.customInstructions || '',
      
      // Profile sections
      sections: {},
      
      // Completeness context
      completenessScore: completenessResult.score,
      missingElements: completenessResult.recommendations.map(r => r.message),
      
      // Analysis instructions
      analysisType: settings.batchAnalysis ? 'batch' : 'individual'
    };
    
    // Prepare each section
    if (profileData.headline) {
      prepared.sections.headline = this.prepareHeadline(profileData.headline);
    }
    
    if (profileData.about) {
      prepared.sections.about = this.prepareAbout(profileData.about);
    }
    
    if (profileData.experience) {
      prepared.sections.experience = this.prepareExperience(profileData.experience);
    }
    
    if (profileData.skills) {
      prepared.sections.skills = this.prepareSkills(profileData.skills);
    }
    
    if (profileData.education) {
      prepared.sections.education = this.prepareEducation(profileData.education);
    }
    
    // Other sections (lower weight)
    prepared.sections.other = this.prepareOtherSections(profileData);
    
    Logger.debug('[QualityScorer] Prepared sections:', Object.keys(prepared.sections));
    
    return prepared;
  },
  
  /**
   * Prepare headline section
   * @param {Object} headline - Headline data
   * @returns {Object} Prepared headline
   */
  prepareHeadline(headline) {
    return {
      text: headline.text || '',
      charCount: headline.charCount || 0,
      hasKeywords: headline.hasKeywords || false,
      isGeneric: headline.isGeneric || false,
      analysis: {
        wordCount: headline.wordCount || 0,
        hasPipe: headline.hasPipe || false,
        hasCompany: headline.hasCompany || false,
        hasValue: headline.hasValue || false
      }
    };
  },
  
  /**
   * Prepare about section
   * @param {Object} about - About data
   * @returns {Object} Prepared about
   */
  prepareAbout(about) {
    return {
      text: about.text || '',
      charCount: about.charCount || 0,
      wordCount: about.wordCount || 0,
      paragraphs: about.paragraphs || [],
      analysis: {
        hasCallToAction: about.hasCallToAction || false,
        keywords: (about.keywords || []).slice(0, 10),
        sentiment: about.sentiment || 'neutral',
        readabilityScore: about.readabilityScore || 0
      }
    };
  },
  
  /**
   * Prepare experience section
   * @param {Object} experience - Experience data
   * @returns {Object} Prepared experience
   */
  prepareExperience(experience) {
    const experiences = experience.experiences || experience.experienceChunks || [];
    
    return {
      count: experience.count || 0,
      hasCurrentRole: experience.hasCurrentRole || false,
      totalMonths: experience.totalMonths || 0,
      experiences: experiences.slice(0, 5).map(exp => ({
        title: exp.title || '',
        company: exp.company || '',
        duration: exp.duration || '',
        description: this.truncateText(exp.description || '', 300),
        hasQuantifiedAchievements: exp.hasQuantifiedAchievements || false,
        hasTechStack: exp.hasTechStack || false
      })),
      analysis: {
        averageTenure: experience.averageTenure || 0,
        careerProgression: experience.careerProgression || 'unknown',
        hasQuantifiedAchievements: experience.hasQuantifiedAchievements || false
      }
    };
  },
  
  /**
   * Prepare skills section
   * @param {Object} skills - Skills data
   * @returns {Object} Prepared skills
   */
  prepareSkills(skills) {
    return {
      count: skills.count || 0,
      topSkills: (skills.skills || []).slice(0, 20).map(s => ({
        name: s.name,
        endorsed: s.endorsementCount > 0
      })),
      analysis: {
        hasEndorsements: skills.hasEndorsements || false,
        technicalCount: skills.technicalSkills?.length || 0,
        softSkillsCount: skills.softSkills?.length || 0,
        categories: Object.keys(skills.skillsByCategory || {})
      }
    };
  },
  
  /**
   * Prepare education section
   * @param {Object} education - Education data
   * @returns {Object} Prepared education
   */
  prepareEducation(education) {
    return {
      count: education.count || 0,
      highestDegree: education.highestDegree || 'none',
      schools: (education.schools || []).slice(0, 3).map(school => ({
        name: school.school || school.name || '',
        degree: school.degree || '',
        field: school.field || ''
      }))
    };
  },
  
  /**
   * Prepare other sections
   * @param {Object} profileData - All profile data
   * @returns {Object} Other sections summary
   */
  prepareOtherSections(profileData) {
    const other = {
      hasRecommendations: false,
      recommendationCount: 0,
      hasCertifications: false,
      certificationCount: 0,
      hasProjects: false,
      projectCount: 0,
      hasFeatured: false
    };
    
    if (profileData.recommendations?.exists) {
      other.hasRecommendations = profileData.recommendations.count > 0;
      other.recommendationCount = profileData.recommendations.receivedCount || 0;
    }
    
    if (profileData.certifications?.exists) {
      other.hasCertifications = profileData.certifications.count > 0;
      other.certificationCount = profileData.certifications.count || 0;
    }
    
    if (profileData.projects?.exists) {
      other.hasProjects = profileData.projects.count > 0;
      other.projectCount = profileData.projects.count || 0;
    }
    
    if (profileData.featured?.exists) {
      other.hasFeatured = profileData.featured.hasContent || false;
    }
    
    return other;
  },
  
  /**
   * Process AI response into structured scoring
   * @param {Object} aiResponse - Response from AI
   * @param {Object} profileData - Original profile data
   * @returns {Object} Processed scores and recommendations
   */
  processAIResponse(aiResponse, profileData) {
    Logger.info('[QualityScorer] Processing AI response');
    
    try {
      // Parse section scores
      const sectionScores = this.parseSectionScores(aiResponse.sectionScores || {});
      
      // Calculate weighted overall score
      const overallScore = this.calculateOverallScore(sectionScores);
      
      // Parse recommendations
      const recommendations = this.parseRecommendations(aiResponse.recommendations || {});
      
      // Parse insights
      const insights = this.parseInsights(aiResponse.insights || {});
      
      // Determine score cap based on missing sections
      const scoreCap = this.determineScoreCap(profileData);
      
      // Apply score cap if necessary
      const finalScore = Math.min(overallScore, scoreCap);
      
      Logger.debug('[QualityScorer] Calculated scores:', {
        raw: overallScore,
        capped: finalScore,
        cap: scoreCap
      });
      
      return {
        contentScore: finalScore,
        sectionScores: sectionScores,
        recommendations: recommendations,
        insights: insights,
        scoreCap: scoreCap,
        analysis: {
          strengths: this.identifyStrengths(sectionScores),
          weaknesses: this.identifyWeaknesses(sectionScores),
          priority: this.prioritizeImprovements(sectionScores, profileData)
        }
      };
      
    } catch (error) {
      Logger.error('[QualityScorer] Error processing AI response:', error);
      
      return {
        contentScore: 5.0,
        error: 'Failed to process AI response',
        sectionScores: {},
        recommendations: {
          critical: ['Unable to analyze profile quality. Please try again.']
        }
      };
    }
  },
  
  /**
   * Parse section scores from AI response
   * @param {Object} scores - Raw section scores
   * @returns {Object} Normalized scores
   */
  parseSectionScores(scores) {
    const normalized = {};
    
    Object.entries(scores).forEach(([section, score]) => {
      // Ensure score is between 0 and 10
      normalized[section] = Math.max(0, Math.min(10, parseFloat(score) || 0));
    });
    
    return normalized;
  },
  
  /**
   * Calculate weighted overall score
   * @param {Object} sectionScores - Section scores
   * @returns {number} Overall score
   */
  calculateOverallScore(sectionScores) {
    let totalScore = 0;
    let totalWeight = 0;
    
    Object.entries(this.weights).forEach(([section, weight]) => {
      const score = sectionScores[section];
      if (score !== undefined) {
        totalScore += score * weight;
        totalWeight += weight;
      }
    });
    
    // Normalize if not all sections were scored
    if (totalWeight > 0 && totalWeight < 1) {
      totalScore = totalScore / totalWeight;
    }
    
    return Math.round(totalScore * 10) / 10; // Round to 1 decimal
  },
  
  /**
   * Determine score cap based on missing critical sections
   * @param {Object} profileData - Profile data
   * @returns {number} Maximum possible score
   */
  determineScoreCap(profileData) {
    let cap = 10;
    
    // Critical sections that cap the score when missing
    if (!profileData.about?.exists || profileData.about?.charCount < 100) {
      cap = Math.min(cap, 7); // No meaningful About = max 7/10
    }
    
    if (!profileData.experience?.exists || profileData.experience?.count === 0) {
      cap = Math.min(cap, 6); // No experience = max 6/10
    }
    
    if (!profileData.skills?.exists || profileData.skills?.count < 5) {
      cap = Math.min(cap, 8); // Few skills = max 8/10
    }
    
    if (!profileData.headline?.exists || profileData.headline?.charCount < 30) {
      cap = Math.min(cap, 8); // Poor headline = max 8/10
    }
    
    return cap;
  },
  
  /**
   * Parse recommendations from AI response
   * @param {Object} recommendations - Raw recommendations
   * @returns {Object} Structured recommendations
   */
  parseRecommendations(recommendations) {
    const structured = {
      critical: [],
      high: [],
      medium: [],
      low: []
    };
    
    // Handle different recommendation formats
    if (Array.isArray(recommendations)) {
      structured.high = recommendations.slice(0, 5);
    } else if (typeof recommendations === 'object') {
      Object.entries(recommendations).forEach(([priority, items]) => {
        if (structured[priority] && Array.isArray(items)) {
          structured[priority] = items;
        }
      });
    }
    
    return structured;
  },
  
  /**
   * Parse insights from AI response
   * @param {Object} insights - Raw insights
   * @returns {Object} Structured insights
   */
  parseInsights(insights) {
    return {
      strengths: insights.strengths || '',
      improvements: insights.improvements || '',
      industryAlignment: insights.industryAlignment || '',
      overallAssessment: insights.overallAssessment || ''
    };
  },
  
  /**
   * Identify profile strengths
   * @param {Object} sectionScores - Section scores
   * @returns {Array<string>} Strengths
   */
  identifyStrengths(sectionScores) {
    const strengths = [];
    
    Object.entries(sectionScores).forEach(([section, score]) => {
      if (score >= 8) {
        strengths.push(`Strong ${section} section (${score}/10)`);
      }
    });
    
    return strengths;
  },
  
  /**
   * Identify profile weaknesses
   * @param {Object} sectionScores - Section scores
   * @returns {Array<string>} Weaknesses
   */
  identifyWeaknesses(sectionScores) {
    const weaknesses = [];
    
    Object.entries(sectionScores).forEach(([section, score]) => {
      if (score < 6) {
        weaknesses.push(`Weak ${section} section (${score}/10)`);
      }
    });
    
    return weaknesses;
  },
  
  /**
   * Prioritize improvements based on scores and weights
   * @param {Object} sectionScores - Section scores
   * @param {Object} profileData - Profile data
   * @returns {Array<Object>} Prioritized improvements
   */
  prioritizeImprovements(sectionScores, profileData) {
    const improvements = [];
    
    Object.entries(this.weights).forEach(([section, weight]) => {
      const score = sectionScores[section] || 0;
      const potentialGain = (10 - score) * weight;
      
      if (score < 8) {
        improvements.push({
          section,
          currentScore: score,
          weight,
          potentialGain,
          priority: potentialGain > 1 ? 'high' : potentialGain > 0.5 ? 'medium' : 'low'
        });
      }
    });
    
    // Sort by potential gain
    improvements.sort((a, b) => b.potentialGain - a.potentialGain);
    
    return improvements;
  },
  
  /**
   * Truncate text to specified length
   * @param {string} text - Text to truncate
   * @param {number} maxLength - Maximum length
   * @returns {string} Truncated text
   */
  truncateText(text, maxLength) {
    if (text.length <= maxLength) return text;
    return text.substring(0, maxLength) + '...';
  },
  
  /**
   * Generate prompt for AI analysis
   * @param {Object} preparedData - Prepared profile data
   * @param {string} analysisType - Type of analysis
   * @returns {string} AI prompt
   */
  generatePrompt(preparedData, analysisType = 'comprehensive') {
    const prompts = {
      comprehensive: `Analyze this LinkedIn profile for a ${preparedData.targetRole} at ${preparedData.seniorityLevel} level. 
        Score each section from 0-10 based on clarity, impact, and relevance to the target role.
        Current completeness: ${preparedData.completenessScore}%.
        Missing elements: ${preparedData.missingElements.join(', ')}.
        
        Provide:
        1. Section scores (0-10) for: headline, about, experience, skills, education, other
        2. Critical recommendations (top 3 most impactful improvements)
        3. High priority recommendations (next 3-5 improvements)
        4. Brief insights on strengths and areas for improvement
        
        ${preparedData.customInstructions}`,
      
      quick: `Quick quality check for LinkedIn profile (${preparedData.targetRole}). 
        Rate overall content quality 0-10 and provide top 3 improvements.`,
      
      section: `Analyze this specific LinkedIn section and rate 0-10 for quality and impact.`
    };
    
    return prompts[analysisType] || prompts.comprehensive;
  }
};


  /* ============================================
   * MODULE: ui/overlay-manager.js
   * ============================================ */
/**
 * Overlay Manager Module for ElevateLI
 * Handles progressive UI states and smooth transitions
 * This module will be concatenated into analyzer.js for Manifest V3 compatibility
 */

const OverlayManager = {
  // UI States
  states: {
    INITIALIZING: 'initializing',
    EMPTY_CACHE: 'empty_cache',
    CACHE_LOADED: 'cache_loaded',
    SCANNING: 'scanning',
    EXTRACTING: 'extracting',
    CALCULATING: 'calculating',
    ANALYZING: 'analyzing',
    AI_ANALYZING: 'ai_analyzing',
    COMPLETE: 'complete',
    ERROR: 'error'
  },
  
  // Current state tracking
  currentState: null,
  overlayElement: null,
  
  /**
   * Initialize overlay and show immediately
   * @returns {OverlayManager} Self for chaining
   */
  async initialize() {
    console.log('[OverlayManager] Initializing overlay');
    this.setState(this.states.INITIALIZING);
    
    // Try to inject immediately
    this.createAndInject();
    
    // If injection failed, retry with delays
    if (!this.overlayElement) {
      console.log('[OverlayManager] Initial injection failed, scheduling retries...');
      
      // Retry after DOM settles
      setTimeout(() => {
        if (!this.overlayElement) {
          console.log('[OverlayManager] Retrying injection (attempt 2)...');
          this.createAndInject();
        }
      }, 1000);
      
      // Final retry after LinkedIn finishes loading
      setTimeout(() => {
        if (!this.overlayElement) {
          console.log('[OverlayManager] Final injection attempt (attempt 3)...');
          this.createAndInject();
        }
      }, 3000);
    }
    
    return this;
  },
  
  /**
   * Create overlay HTML with skeleton UI
   */
  createAndInject() {
    // Create wrapper for proper integration
    const wrapperHtml = `
      <div class="elevateli-overlay-wrapper artdeco-card pv-profile-card break-words mt4">
        <div id="elevateli-overlay" class="elevateli-overlay" data-state="${this.currentState}">
          <div class="overlay-header">
            <div class="header-left">
              <h3>ElevateLI Analysis</h3>
              <span class="last-analyzed" style="font-size: 12px; color: #666; margin-left: 12px; opacity: 0;"></span>
            </div>
            <div class="header-right">
              <button class="overlay-close" aria-label="Close overlay">&times;</button>
            </div>
          </div>
        
        <div class="scores-container">
          <div class="score-block completeness">
            <label>Profile Completeness</label>
            <div class="score-display">
              <span class="score-value skeleton">--</span>
              <span class="score-suffix">%</span>
            </div>
            <div class="score-bar">
              <div class="score-bar-fill skeleton" style="width: 0%"></div>
            </div>
          </div>
          
          <div class="score-block quality">
            <label>Content Quality (AI)</label>
            <div class="score-display">
              <span class="score-value skeleton">--</span>
              <span class="score-suffix">/10</span>
            </div>
            <div class="score-bar">
              <div class="score-bar-fill skeleton" style="width: 0%"></div>
            </div>
            <div class="ai-status"></div>
          </div>
        </div>
        
        <div class="status-indicator">
          <span class="status-icon"></span>
          <span class="status-text">Initializing...</span>
        </div>
        
        <div class="scan-progress hidden">
          <h4>Scanning Profile Sections</h4>
          <div class="scan-items"></div>
        </div>
        
        <div class="missing-items-section hidden">
          <h4>To Reach 100% Completeness</h4>
          <div class="missing-items-list"></div>
        </div>
        
        <div class="recommendations-section hidden">
          <h4>Top Recommendations</h4>
          <ul class="recommendations-list"></ul>
        </div>
        
        <div class="insights-section hidden">
          <h4>Key Insights</h4>
          <div class="insights-content"></div>
        </div>
        
        <div class="overlay-actions">
          <button class="action-button analyze-button hidden">
            <span class="button-icon">🚀</span>
            Analyze Profile
          </button>
          <button class="action-button refresh-button hidden">
            <span class="button-icon">🔄</span>
            Re-analyze
          </button>
          <button class="action-button details-button hidden">
            <span class="button-icon">📊</span>
            View Details
          </button>
        </div>
      </div>
      </div><!-- Close wrapper -->
    `;
    
    // Remove any existing overlay wrapper
    const existingWrapper = document.querySelector('.elevateli-overlay-wrapper');
    if (existingWrapper) existingWrapper.remove();
    
    // Find the right place to inject
    let injected = false;
    
    // Log available elements for debugging
    Logger.debug('[OverlayManager] Looking for injection points...', {
      profileCard: !!document.querySelector('section.artdeco-card[data-member-id]'),
      profileSection: !!document.querySelector('.pv-top-card'),
      aboutSection: !!document.querySelector('#about'),
      mainContent: !!document.querySelector('main'),
      scaffoldMain: !!document.querySelector('.scaffold-layout__main')
    });
    
    // Strategy 1: After the profile top card (most common location)
    const topCard = document.querySelector('.pv-top-card');
    if (topCard && topCard.parentElement) {
      Logger.info('[OverlayManager] Injecting after profile top card');
      topCard.parentElement.insertAdjacentHTML('afterend', wrapperHtml);
      injected = true;
    }
    
    // Strategy 2: After the profile photo/intro section
    if (!injected) {
      const profileSection = document.querySelector('section.artdeco-card.pv-top-card-profile-picture');
      if (profileSection) {
        Logger.info('[OverlayManager] Injecting after profile intro section');
        profileSection.insertAdjacentHTML('afterend', wrapperHtml);
        injected = true;
      }
    }
    
    // Strategy 3: After any section with class pv-profile-card
    if (!injected) {
      const profileCards = document.querySelectorAll('section.pv-profile-card');
      if (profileCards.length > 0) {
        Logger.info('[OverlayManager] Injecting after first profile card');
        profileCards[0].insertAdjacentHTML('afterend', wrapperHtml);
        injected = true;
      }
    }
    
    // Strategy 4: After About section (if exists)
    if (!injected) {
      const aboutSection = document.querySelector('section#about, div#about');
      if (aboutSection && aboutSection.parentElement) {
        Logger.info('[OverlayManager] Injecting after About section');
        aboutSection.parentElement.insertAdjacentHTML('afterend', wrapperHtml);
        injected = true;
      }
    }
    
    // Strategy 5: Inside main content area
    if (!injected) {
      const mainContent = document.querySelector('main.scaffold-layout__main, main[role="main"]');
      if (mainContent) {
        // Find the container that holds profile sections
        const profileContainer = mainContent.querySelector('.pv-profile-body-container, .scaffold-layout__inner');
        if (profileContainer) {
          Logger.info('[OverlayManager] Injecting in profile container');
          profileContainer.insertAdjacentHTML('afterbegin', wrapperHtml);
          injected = true;
        } else {
          Logger.info('[OverlayManager] Injecting at beginning of main content');
          mainContent.insertAdjacentHTML('afterbegin', wrapperHtml);
          injected = true;
        }
      }
    }
    
    // Strategy 6: Any artdeco-card (very generic fallback)
    if (!injected) {
      const anyCard = document.querySelector('section.artdeco-card');
      if (anyCard) {
        Logger.info('[OverlayManager] Injecting after first artdeco card (generic fallback)');
        anyCard.insertAdjacentHTML('afterend', wrapperHtml);
        injected = true;
      }
    }
    
    if (!injected) {
      Logger.error('[OverlayManager] Failed to inject overlay - no suitable location found', {
        url: window.location.href,
        hasMain: !!document.querySelector('main'),
        hasBody: !!document.body,
        bodyChildren: document.body.children.length
      });
      return;
    }
    
    this.overlayElement = document.getElementById('elevateli-overlay');
    
    // Attach event listeners
    this.attachEventListeners();
    
    console.log('[OverlayManager] Overlay injected into DOM');
  },
  
  /**
   * Attach event listeners to overlay elements
   */
  attachEventListeners() {
    // Close button
    const closeBtn = this.overlayElement.querySelector('.overlay-close');
    closeBtn?.addEventListener('click', () => this.close());
    
    // Analyze button (for first-time analysis)
    const analyzeBtn = this.overlayElement.querySelector('.analyze-button');
    analyzeBtn?.addEventListener('click', () => this.handleAnalyze());
    
    // Refresh button (for re-analysis)
    const refreshBtn = this.overlayElement.querySelector('.refresh-button');
    refreshBtn?.addEventListener('click', () => this.handleRefresh());
    
    // Details button
    const detailsBtn = this.overlayElement.querySelector('.details-button');
    detailsBtn?.addEventListener('click', () => this.handleViewDetails());
  },
  
  /**
   * Update overlay state and UI
   * @param {string} newState - New state from states enum
   * @param {Object} data - Data for the new state
   */
  setState(newState, data = {}) {
    console.log(`[OverlayManager] State change: ${this.currentState} → ${newState}`);
    this.currentState = newState;
    
    if (!this.overlayElement) return;
    
    this.overlayElement.setAttribute('data-state', newState);
    
    // State-specific updates
    const stateHandlers = {
      [this.states.INITIALIZING]: () => {
        this.updateStatus('Initializing analysis...', '⣾');
        this.showSkeletons();
        // Show analyze button for first-time analysis
        this.showActionButtons({ showAnalyze: true, showDetails: false });
      },
      
      [this.states.EMPTY_CACHE]: () => {
        this.updateStatus('No previous analysis found', 'ℹ️');
        this.hideSkeletons();
        
        // Show empty state message
        const scoresContainer = this.overlayElement.querySelector('.scores-container');
        if (scoresContainer) {
          scoresContainer.innerHTML = `
            <div class="empty-state-message" style="
              grid-column: 1 / -1;
              text-align: center;
              padding: 30px 20px;
              color: #666;
            ">
              <div style="font-size: 48px; margin-bottom: 16px; opacity: 0.3;">📊</div>
              <p style="margin-bottom: 12px; font-size: 16px; font-weight: 600;">
                This profile hasn't been analyzed yet
              </p>
              <p style="font-size: 14px; color: #999;">
                Click below to generate your profile scores
              </p>
            </div>
          `;
        }
        
        // Show prominent analyze button
        this.showActionButtons({ 
          showAnalyze: true,
          showRefresh: false,
          showDetails: false 
        });
      },
      
      [this.states.CACHE_LOADED]: () => {
        this.clearEmptyStateMessage();
        this.updateStatus('Analysis complete', '✓');
        this.hideSkeletons();
        this.populateScores(data);
        this.showMissingItems(data.completenessData);
        this.showRecommendations(data.recommendations);
        // Show timestamp
        if (data.timestamp) {
          this.showTimestamp(data.timestamp);
        }
        // Show re-analyze button for cached results
        this.showActionButtons({ showRefresh: true });
      },
      
      [this.states.SCANNING]: () => {
        this.clearEmptyStateMessage();
        this.updateStatus('Scanning profile sections...', '⣾');
        this.showScanProgress();
      },
      
      [this.states.EXTRACTING]: () => {
        this.updateStatus('Extracting profile data...', '⣾');
        this.hideScanProgress();
        this.showProgressBar('extracting');
      },
      
      [this.states.CALCULATING]: () => {
        this.updateStatus('Calculating completeness...', '⣾');
        if (data.completeness !== undefined) {
          this.updateCompleteness(data.completeness);
        }
      },
      
      [this.states.ANALYZING]: () => {
        this.updateStatus('Running AI analysis...', '⣾');
        if (data.completeness !== undefined) {
          this.updateCompleteness(data.completeness);
        }
        this.showProgressBar('analyzing');
      },
      
      [this.states.AI_ANALYZING]: () => {
        this.updateStatus('AI analyzing profile sections...', '⣾');
        this.hideScanProgress();
        if (data.completeness !== undefined) {
          this.updateCompleteness(data.completeness);
        }
      },
      
      [this.states.COMPLETE]: () => {
        this.clearEmptyStateMessage();
        this.updateStatus('Analysis complete', '✓');
        this.hideSkeletons();
        this.populateScores(data);
        this.showMissingItems(data.completenessData);
        this.showRecommendations(data.recommendations);
        this.showInsights(data.insights);
        // Show timestamp
        if (data.timestamp) {
          this.showTimestamp(data.timestamp);
        }
        // Show re-analyze button after fresh analysis
        this.showActionButtons({ showRefresh: true });
      },
      
      [this.states.ERROR]: () => {
        // Determine error icon and message based on type
        let errorIcon = '❌';
        let errorMessage = data.message || 'Analysis failed';
        let showSettings = false;
        
        if (data.aiError) {
          switch (data.aiError.type) {
            case 'AUTH':
              errorIcon = '🔑';
              showSettings = true;
              break;
            case 'RATE_LIMIT':
              errorIcon = '⏱️';
              if (data.aiError.retryAfter) {
                errorMessage = data.aiError.message;
                // Start countdown timer
                this.startRetryCountdown(data.aiError.retryAfter);
              }
              break;
            case 'NETWORK':
              errorIcon = '🌐';
              break;
            case 'SERVICE_UNAVAILABLE':
              errorIcon = '🔧';
              break;
            default:
              errorIcon = '⚠️';
          }
          errorMessage = data.aiError.message;
        }
        
        this.updateStatus(errorMessage, errorIcon);
        this.hideSkeletons();
        
        // Show completeness if available (analysis partially succeeded)
        if (data.completeness !== undefined) {
          this.updateCompleteness(data.completeness);
        }
        
        // Show appropriate action button
        if (showSettings) {
          // Show button to open settings
          this.showActionButtons({ showSettings: true });
        } else {
          // Show analyze button to retry
          this.showActionButtons({ showAnalyze: true });
        }
      }
    };
    
    // Execute state handler
    const handler = stateHandlers[newState];
    if (handler) {
      handler();
    }
  },
  
  /**
   * Update status indicator
   * @param {string} text - Status message
   * @param {string} icon - Status icon
   */
  updateStatus(text, icon = '') {
    const statusText = this.overlayElement.querySelector('.status-text');
    const statusIcon = this.overlayElement.querySelector('.status-icon');
    
    if (statusText) {
      statusText.style.opacity = '0';
      setTimeout(() => {
        statusText.textContent = text;
        statusText.style.opacity = '1';
      }, 150);
    }
    
    if (statusIcon && icon) {
      statusIcon.textContent = icon;
      statusIcon.className = 'status-icon';
      if (icon === '⣾') {
        statusIcon.classList.add('spinning');
      }
    }
  },
  
  /**
   * Show skeleton loaders
   */
  showSkeletons() {
    const skeletons = this.overlayElement.querySelectorAll('.skeleton');
    skeletons.forEach(el => el.classList.add('loading'));
  },
  
  /**
   * Hide skeleton loaders
   */
  hideSkeletons() {
    const skeletons = this.overlayElement.querySelectorAll('.skeleton');
    skeletons.forEach(el => {
      el.classList.remove('skeleton', 'loading');
    });
  },
  
  /**
   * Clear empty state message
   */
  clearEmptyStateMessage() {
    const emptyMessage = this.overlayElement.querySelector('.empty-state-message');
    if (emptyMessage) {
      emptyMessage.remove();
    }
    
    // Also restore scores container if it was cleared
    const scoresContainer = this.overlayElement.querySelector('.scores-container');
    if (scoresContainer && !scoresContainer.querySelector('.score-block')) {
      // Restore the score blocks structure
      scoresContainer.innerHTML = `
        <div class="score-block completeness">
          <label>Profile Completeness</label>
          <div class="score-value skeleton">--</div>
          <div class="score-bar">
            <div class="score-bar-fill skeleton"></div>
          </div>
          <span class="score-unit">%</span>
        </div>
        
        <div class="score-block quality">
          <label>Content Quality (AI)</label>
          <div class="score-value skeleton">--</div>
          <div class="score-bar">
            <div class="score-bar-fill skeleton"></div>
          </div>
          <span class="score-unit">/10</span>
        </div>
      `;
    }
  },
  
  /**
   * Update completeness score
   * @param {number} score - Completeness percentage
   */
  updateCompleteness(score) {
    const valueEl = this.overlayElement.querySelector('.completeness .score-value');
    const barEl = this.overlayElement.querySelector('.completeness .score-bar-fill');
    
    if (valueEl) {
      valueEl.textContent = Math.round(score);
      valueEl.classList.remove('skeleton');
    }
    
    if (barEl) {
      barEl.style.width = `${score}%`;
      barEl.classList.remove('skeleton');
      
      // Color based on score
      if (score >= 80) barEl.style.backgroundColor = '#057642';
      else if (score >= 60) barEl.style.backgroundColor = '#f59e0b';
      else barEl.style.backgroundColor = '#dc2626';
    }
  },
  
  /**
   * Populate all scores
   * @param {Object} data - Score data
   */
  populateScores(data) {
    // Log section scores if available
    if (data.sectionScores) {
      console.log('[OverlayManager] Section scores:', data.sectionScores);
    }
    
    // Update completeness
    if (data.completeness !== undefined) {
      this.updateCompleteness(data.completeness);
    }
    
    // Check if AI is disabled
    if (data.aiDisabled || (!data.contentScore && data.fromCache !== true)) {
      // Replace quality score block with AI disabled message
      const qualityBlock = this.overlayElement.querySelector('.score-block.quality');
      if (qualityBlock) {
        qualityBlock.innerHTML = `
          <label>Content Quality (AI)</label>
          <div class="ai-disabled-message">
            Configure AI in extension settings
          </div>
        `;
      }
    } else if (data.contentScore !== undefined) {
      // Update quality score normally
      const valueEl = this.overlayElement.querySelector('.quality .score-value');
      const barEl = this.overlayElement.querySelector('.quality .score-bar-fill');
      const statusEl = this.overlayElement.querySelector('.ai-status');
      
      if (valueEl) {
        valueEl.textContent = data.contentScore.toFixed(1);
        valueEl.classList.remove('skeleton');
      }
      
      if (barEl) {
        barEl.style.width = `${data.contentScore * 10}%`;
        barEl.classList.remove('skeleton');
        
        // Color based on score
        if (data.contentScore >= 8) barEl.style.backgroundColor = '#057642';
        else if (data.contentScore >= 6) barEl.style.backgroundColor = '#f59e0b';
        else barEl.style.backgroundColor = '#dc2626';
      }
      
      if (statusEl) {
        statusEl.textContent = data.fromCache ? 'Cached' : 'Fresh';
      }
    }
  },
  
  /**
   * Show timestamp
   * @param {number} timestamp - Unix timestamp
   */
  showTimestamp(timestamp) {
    const timestampEl = this.overlayElement.querySelector('.timestamp-display');
    if (!timestampEl || !timestamp) return;
    
    const date = new Date(timestamp);
    const formatted = date.toLocaleString(undefined, {
      month: 'short',
      day: 'numeric',
      year: 'numeric',
      hour: 'numeric',
      minute: '2-digit',
      hour12: true
    });
    
    timestampEl.textContent = `Last analyzed: ${formatted}`;
    timestampEl.style.opacity = '1';
  },
  
  /**
   * Show recommendations with categorization
   * @param {Array|Object} recommendations - Recommendations data
   */
  showRecommendations(recommendations) {
    console.log('[OverlayManager] showRecommendations called with:', recommendations);
    
    if (!recommendations) {
      console.log('[OverlayManager] No recommendations provided');
      return;
    }
    
    const section = this.overlayElement.querySelector('.recommendations-section');
    const list = this.overlayElement.querySelector('.recommendations-list');
    
    if (!section || !list) {
      console.log('[OverlayManager] Recommendations section or list not found');
      return;
    }
    
    // Clear existing
    list.innerHTML = '';
    
    // Create categorized structure
    const categories = {
      critical: { items: [], label: '🔴 Critical Actions', time: '15 min' },
      high: { items: [], label: '🟡 High Impact', time: '30 min' },
      medium: { items: [], label: '🟢 Nice to Have', time: '1 hour' }
    };
    
    // Categorize recommendations
    let allRecs = [];
    if (Array.isArray(recommendations)) {
      allRecs = recommendations;
    } else {
      if (recommendations.critical) allRecs = allRecs.concat(recommendations.critical.map(r => ({...r, priority: 'critical'})));
      if (recommendations.important) allRecs = allRecs.concat(recommendations.important.map(r => ({...r, priority: 'high'})));
      if (recommendations.niceToHave) allRecs = allRecs.concat(recommendations.niceToHave.map(r => ({...r, priority: 'medium'})));
    }
    
    // Sort into categories
    allRecs.forEach(rec => {
      const priority = rec.priority || 'medium';
      if (categories[priority]) {
        categories[priority].items.push(rec);
      }
    });
    
    // Display by category
    Object.entries(categories).forEach(([priority, category]) => {
      if (category.items.length === 0) return;
      
      // Create category header
      const categoryDiv = document.createElement('div');
      categoryDiv.className = 'recommendation-category';
      categoryDiv.style.cssText = 'margin-bottom: 16px;';
      
      const header = document.createElement('h5');
      header.style.cssText = 'font-size: 13px; font-weight: 600; margin: 0 0 8px 0; color: #333; display: flex; align-items: center; justify-content: space-between;';
      header.innerHTML = `
        <span>${category.label}</span>
        <span style="font-size: 11px; color: #666; font-weight: normal;">~${category.time}</span>
      `;
      categoryDiv.appendChild(header);
      
      const categoryList = document.createElement('ul');
      categoryList.style.cssText = 'list-style: none; padding: 0; margin: 0;';
      
      // Add items to category
      category.items.slice(0, 3).forEach(rec => {
        const li = document.createElement('li');
        li.className = 'recommendation-item';
        li.style.cssText = 'padding: 8px 0; padding-left: 24px; position: relative; font-size: 13px; line-height: 1.5;';
        
        // Extract recommendation details
        const action = rec.action || {};
        const what = action.what || rec.what || rec.message || rec;
        const why = action.why || rec.why;
        const example = action.example || rec.example;
        const impact = rec.impactScore || rec.impact;
        
        // Create content structure
        let content = `<div style="margin-bottom: 4px;">${what}</div>`;
        
        if (why) {
          content += `<div style="font-size: 12px; color: #666; margin-top: 4px;">→ ${why}</div>`;
        }
        
        if (example) {
          content += `<div style="font-size: 11px; color: #0a66c2; margin-top: 4px; font-style: italic;">${example}</div>`;
        }
        
        if (impact) {
          content += `<div style="font-size: 11px; color: #057642; margin-top: 4px;">+${impact} points</div>`;
        }
        
        li.innerHTML = content;
        
        // Add hover effect
        li.onmouseover = () => li.style.backgroundColor = '#f3f2ef';
        li.onmouseout = () => li.style.backgroundColor = 'transparent';
        
        categoryList.appendChild(li);
      });
      
      categoryDiv.appendChild(categoryList);
      list.appendChild(categoryDiv);
    });
    
    if (list.children.length > 0) {
      section.classList.remove('hidden');
    }
  },
  
  /**
   * Show insights
   * @param {Object} insights - Insights data
   */
  showInsights(insights) {
    if (!insights) return;
    
    const section = this.overlayElement.querySelector('.insights-section');
    const content = this.overlayElement.querySelector('.insights-content');
    
    if (!section || !content) return;
    
    // Format insights
    let insightText = '';
    if (insights.strengths) {
      insightText += `<strong>Strengths:</strong> ${insights.strengths}<br>`;
    }
    if (insights.improvements) {
      insightText += `<strong>Areas to improve:</strong> ${insights.improvements}`;
    }
    
    if (insightText) {
      content.innerHTML = insightText;
      section.classList.remove('hidden');
    }
  },
  
  /**
   * Start retry countdown timer
   * @param {number} seconds - Seconds to wait
   */
  startRetryCountdown(seconds) {
    const analyzeBtn = this.overlayElement.querySelector('.analyze-button');
    if (!analyzeBtn) return;
    
    // Clear any existing timer
    if (this.countdownTimer) {
      clearInterval(this.countdownTimer);
    }
    
    let remaining = seconds;
    analyzeBtn.classList.remove('hidden');
    analyzeBtn.disabled = true;
    
    const updateButton = () => {
      if (remaining > 0) {
        analyzeBtn.innerHTML = `<span class="button-icon">⏱️</span>Retry in ${remaining}s`;
        remaining--;
      } else {
        clearInterval(this.countdownTimer);
        analyzeBtn.disabled = false;
        analyzeBtn.innerHTML = '<span class="button-icon">🔄</span>Retry Analysis';
        // Restore original click handler
        analyzeBtn.onclick = () => this.handleAnalyze();
      }
    };
    
    updateButton();
    this.countdownTimer = setInterval(updateButton, 1000);
  },
  
  /**
   * Show action buttons based on current state
   * @param {Object} options - Button visibility options
   */
  showActionButtons(options = {}) {
    const analyzeBtn = this.overlayElement.querySelector('.analyze-button');
    const refreshBtn = this.overlayElement.querySelector('.refresh-button');
    const detailsBtn = this.overlayElement.querySelector('.details-button');
    
    // Hide all buttons first
    [analyzeBtn, refreshBtn, detailsBtn].forEach(btn => btn?.classList.add('hidden'));
    
    // Show appropriate buttons based on state
    if (options.showAnalyze && analyzeBtn) {
      analyzeBtn.classList.remove('hidden');
      // Update text based on current state
      if (this.currentState === this.states.EMPTY_CACHE) {
        analyzeBtn.innerHTML = '<span class="button-icon">🚀</span>Analyze Profile';
      } else {
        analyzeBtn.innerHTML = '<span class="button-icon">🔄</span>Re-analyze';
      }
    }
    if (options.showRefresh && refreshBtn) {
      refreshBtn.classList.remove('hidden');
      // Reset button state after analysis completes
      refreshBtn.disabled = false;
      refreshBtn.innerHTML = '<span class="button-icon">🔄</span>Re-analyze';
    }
    if (options.showSettings && analyzeBtn) {
      // Repurpose analyze button for settings
      analyzeBtn.classList.remove('hidden');
      analyzeBtn.innerHTML = '<span class="button-icon">⚙️</span>Open Settings';
      // Change click handler temporarily
      analyzeBtn.onclick = (e) => {
        e.preventDefault();
        // Open extension popup/settings
        chrome.runtime.sendMessage({ action: 'openPopup' });
      };
    }
  },
  
  /**
   * Show progress bar
   * @param {string} phase - Current phase
   */
  showProgressBar(phase) {
    // Could add a progress bar UI element if desired
    console.log(`[OverlayManager] Progress phase: ${phase}`);
  },
  
  /**
   * Handle analyze button click (first-time analysis)
   */
  handleAnalyze() {
    console.log('[OverlayManager] Analysis requested');
    const btn = this.overlayElement.querySelector('.analyze-button');
    if (btn) {
      btn.disabled = true;
      btn.innerHTML = '<span class="button-icon">⏳</span>Analyzing...';
    }
    // Send message to trigger analysis
    window.postMessage({ type: 'ELEVATE_REFRESH' }, '*');
  },
  
  /**
   * Handle refresh button click (re-analysis)
   */
  handleRefresh() {
    console.log('[OverlayManager] Refresh requested');
    const btn = this.overlayElement.querySelector('.refresh-button');
    if (btn) {
      btn.disabled = true;
      btn.innerHTML = '<span class="button-icon">⏳</span>Re-analyzing...';
    }
    // Send message to trigger re-analysis
    window.postMessage({ type: 'ELEVATE_REFRESH' }, '*');
  },
  
  /**
   * Handle view details button click
   */
  handleViewDetails() {
    console.log('[OverlayManager] View details requested');
    const btn = this.overlayElement.querySelector('.details-button');
    if (btn) {
      btn.disabled = true;
    }
    // Open dashboard
    chrome.runtime.sendMessage({ action: 'openDashboard' }, (response) => {
      if (chrome.runtime.lastError) {
        console.error('Failed to open dashboard:', chrome.runtime.lastError);
        if (btn) btn.disabled = false;
      }
    });
  },
  
  /**
   * Close overlay
   */
  close() {
    const wrapper = document.querySelector('.elevateli-overlay-wrapper');
    if (wrapper) {
      wrapper.style.opacity = '0';
      setTimeout(() => {
        wrapper.remove();
        this.overlayElement = null;
      }, 300);
    }
  },
  
  /**
   * Show scan progress UI
   */
  showScanProgress() {
    const scanProgress = this.overlayElement.querySelector('.scan-progress');
    if (scanProgress) {
      scanProgress.classList.remove('hidden');
    }
  },
  
  /**
   * Hide scan progress UI
   */
  hideScanProgress() {
    const scanProgress = this.overlayElement.querySelector('.scan-progress');
    if (scanProgress) {
      scanProgress.classList.add('hidden');
    }
  },
  
  /**
   * Update scan progress with section statuses
   * @param {Array<Object>} sections - Array of {name, status, itemCount}
   */
  updateScanProgress(sections) {
    const scanItems = this.overlayElement.querySelector('.scan-items');
    if (!scanItems) return;
    
    // Clear existing items
    scanItems.innerHTML = '';
    
    // Create progress items for each section
    sections.forEach(section => {
      const item = document.createElement('div');
      item.className = 'scan-item';
      item.setAttribute('data-status', section.status);
      
      const icon = document.createElement('span');
      icon.className = 'scan-icon';
      
      // Set icon based on status
      if (section.status === 'complete') {
        icon.textContent = '✓';
      } else if (section.status === 'scanning') {
        icon.textContent = '⣾';
        icon.classList.add('spinning');
      } else {
        icon.textContent = '○';
      }
      
      const label = document.createElement('span');
      label.className = 'scan-label';
      label.textContent = this.formatSectionName(section.name);
      
      // Add item count if available
      if (section.itemCount !== undefined && section.status === 'complete') {
        const count = document.createElement('span');
        count.className = 'scan-count';
        count.textContent = `(${section.itemCount})`;
        label.appendChild(count);
      }
      
      item.appendChild(icon);
      item.appendChild(label);
      scanItems.appendChild(item);
    });
  },
  
  /**
   * Update extraction progress
   * @param {string} currentSection - Section currently being extracted
   */
  updateExtractionProgress(currentSection) {
    const statusText = this.overlayElement.querySelector('.status-text');
    if (statusText) {
      statusText.textContent = `Extracting ${this.formatSectionName(currentSection)}...`;
    }
  },
  
  /**
   * Update AI analysis progress
   * @param {string} phase - Current AI phase
   * @param {string} section - Current section (optional)
   */
  updateAIProgress(phase, section) {
    const statusText = this.overlayElement.querySelector('.status-text');
    if (!statusText) return;
    
    const messages = {
      'generating': 'Generating AI insights...',
      'analyzing-about': 'AI analyzing About section...',
      'analyzing-experience': 'AI analyzing Experience...',
      'analyzing-skills': 'AI analyzing Skills...',
      'analyzing-headline': 'AI analyzing Headline...',
      'analyzing-education': 'AI analyzing Education...',
      'analyzing-recommendations': 'AI analyzing Recommendations...',
      'analyzing-certifications': 'AI analyzing Certifications...',
      'analyzing-projects': 'AI analyzing Projects...'
    };
    
    statusText.textContent = messages[phase] || `AI analyzing ${section || 'profile'}...`;
  },
  
  /**
   * Show timestamp
   * @param {string|number} timestamp - Timestamp (ISO string or Unix timestamp)
   */
  showTimestamp(timestamp) {
    const timestampEl = this.overlayElement?.querySelector('.timestamp-display');
    if (!timestampEl || !timestamp) return;
    
    let date;
    if (typeof timestamp === 'string') {
      date = new Date(timestamp);
    } else {
      date = new Date(timestamp);
    }
    
    const formatted = date.toLocaleString(undefined, {
      month: 'short',
      day: 'numeric',
      year: 'numeric',
      hour: 'numeric',
      minute: '2-digit',
      hour12: true
    });
    
    timestampEl.textContent = `Last analyzed: ${formatted}`;
    timestampEl.style.opacity = '1';
  },
  
  /**
   * Format section name for display
   * @param {string} name - Section name
   * @returns {string} Formatted name
   */
  formatSectionName(name) {
    const nameMap = {
      'headline': 'Headline',
      'about': 'About',
      'experience': 'Experience',
      'skills': 'Skills',
      'education': 'Education',
      'recommendations': 'Recommendations',
      'certifications': 'Certifications',
      'projects': 'Projects',
      'featured': 'Featured',
      'profile_intro': 'Profile Intro',
      'experience_role': 'Experience'
    };
    
    return nameMap[name] || name.charAt(0).toUpperCase() + name.slice(1);
  },
  
  /**
   * Update section score progressively
   * @param {string} section - Section name
   * @param {number} score - Section score
   */
  updateSectionScore(section, score) {
    // Create or update section scores display
    let scoresDisplay = this.overlayElement.querySelector('.section-scores-display');
    if (!scoresDisplay) {
      scoresDisplay = document.createElement('div');
      scoresDisplay.className = 'section-scores-display';
      scoresDisplay.style.cssText = 'margin: 16px 0; padding: 12px; background: #f3f2ef; border-radius: 6px;';
      
      const statusIndicator = this.overlayElement.querySelector('.status-indicator');
      if (statusIndicator) {
        statusIndicator.insertAdjacentElement('afterend', scoresDisplay);
      }
    }
    
    // Update or add section score
    let sectionItem = scoresDisplay.querySelector(`[data-section="${section}"]`);
    if (!sectionItem) {
      sectionItem = document.createElement('div');
      sectionItem.setAttribute('data-section', section);
      sectionItem.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 4px 0; font-size: 13px;';
      scoresDisplay.appendChild(sectionItem);
    }
    
    // Format section name
    const displayName = this.formatSectionName(section);
    const scoreColor = score >= 8 ? '#057642' : score >= 6 ? '#f59e0b' : '#dc2626';
    
    sectionItem.innerHTML = `
      <span>${displayName}</span>
      <span style="font-weight: 600; color: ${scoreColor};">${score.toFixed(1)}/10</span>
    `;
    
    // Add animation
    sectionItem.style.opacity = '0';
    setTimeout(() => {
      sectionItem.style.transition = 'opacity 0.3s ease';
      sectionItem.style.opacity = '1';
    }, 50);
  },
  
  /**
   * Show missing items for completeness
   * @param {Object} completenessData - Completeness analysis data
   */
  showMissingItems(completenessData) {
    if (!completenessData || !completenessData.recommendations) return;
    
    const section = this.overlayElement.querySelector('.missing-items-section');
    const list = this.overlayElement.querySelector('.missing-items-list');
    
    if (!section || !list) return;
    
    // Clear existing items
    list.innerHTML = '';
    
    // Get missing items sorted by priority (highest weight first)
    const missingItems = completenessData.recommendations;
    if (!missingItems || missingItems.length === 0) {
      // If 100% complete, hide the section
      section.classList.add('hidden');
      return;
    }
    
    // Create a clean list of missing items
    const itemsHtml = missingItems.slice(0, 5).map(item => {
      const iconMap = {
        photo: '📷',
        headline: '📝',
        about: '📄',
        experience: '💼',
        skills: '🎯',
        education: '🎓',
        recommendations: '👍',
        certifications: '📜',
        projects: '🚀'
      };
      
      const icon = iconMap[item.section] || '•';
      const points = item.impact || item.weight || 0;
      
      return `
        <div class="missing-item" style="
          display: flex;
          align-items: center;
          gap: 8px;
          padding: 8px 0;
          border-bottom: 1px solid #e0e0e0;
          font-size: 13px;
        ">
          <span style="font-size: 16px;">${icon}</span>
          <span style="flex: 1;">${item.message}</span>
          <span style="
            background: #f3f4f6;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            color: #666;
          ">+${points}%</span>
        </div>
      `;
    }).join('');
    
    list.innerHTML = itemsHtml;
    
    // Show the section
    section.classList.remove('hidden');
    
    // If there are more than 5 items, show count
    if (missingItems.length > 5) {
      list.innerHTML += `
        <div style="
          text-align: center;
          padding: 8px 0;
          font-size: 13px;
          color: #666;
        ">
          and ${missingItems.length - 5} more items...
        </div>
      `;
    }
  },
  
  /**
   * Format and display timestamp
   * @param {number} timestamp - Unix timestamp
   */
  showTimestamp(timestamp) {
    const lastAnalyzed = this.overlayElement.querySelector('.last-analyzed');
    if (!lastAnalyzed) return;
    
    const formatted = this.formatTimestamp(timestamp);
    lastAnalyzed.textContent = `Last analyzed: ${formatted}`;
    lastAnalyzed.style.opacity = '1';
  },
  
  /**
   * Format timestamp to human-readable format
   * @param {number} timestamp - Unix timestamp
   * @returns {string} Formatted date/time string
   */
  formatTimestamp(timestamp) {
    const date = new Date(timestamp);
    const now = new Date();
    
    // Check if it's today
    const isToday = date.toDateString() === now.toDateString();
    
    // Check if it's yesterday
    const yesterday = new Date(now);
    yesterday.setDate(yesterday.getDate() - 1);
    const isYesterday = date.toDateString() === yesterday.toDateString();
    
    // Format time
    const timeOptions = { hour: 'numeric', minute: '2-digit', hour12: true };
    const timeStr = date.toLocaleTimeString('en-US', timeOptions);
    
    if (isToday) {
      return `Today at ${timeStr}`;
    } else if (isYesterday) {
      return `Yesterday at ${timeStr}`;
    } else {
      // For older dates, show month/day and time
      const dateOptions = { month: 'short', day: 'numeric' };
      const dateStr = date.toLocaleDateString('en-US', dateOptions);
      return `${dateStr} at ${timeStr}`;
    }
  }
};


  /* ============================================
   * MODULE: analyzer-base.js
   * ============================================ */
/**
 * ElevateLI Analyzer Base
 * Main orchestrator for LinkedIn profile analysis
 * Expects these modules to be available: Logger, CacheManager, OverlayManager, extractors, scorers
 */

// Note: Constants SELECTORS, TIMINGS, ExtensionState are assumed to be already defined
// from previously loaded modules in the concatenated analyzer.js

/* ============================================
 * ANALYZER CLASS
 * ============================================ */
class Analyzer {
  constructor() {
    // Available extractors (will be defined in separate files)
    this.extractors = {
      photo: typeof PhotoExtractor !== 'undefined' ? PhotoExtractor : null,
      headline: typeof HeadlineExtractor !== 'undefined' ? HeadlineExtractor : null,
      about: typeof AboutExtractor !== 'undefined' ? AboutExtractor : null,
      experience: typeof ExperienceExtractor !== 'undefined' ? ExperienceExtractor : null,
      skills: typeof SkillsExtractor !== 'undefined' ? SkillsExtractor : null,
      education: typeof EducationExtractor !== 'undefined' ? EducationExtractor : null,
      recommendations: typeof RecommendationsExtractor !== 'undefined' ? RecommendationsExtractor : null,
      certifications: typeof CertificationsExtractor !== 'undefined' ? CertificationsExtractor : null,
      projects: typeof ProjectsExtractor !== 'undefined' ? ProjectsExtractor : null,
      featured: typeof FeaturedExtractor !== 'undefined' ? FeaturedExtractor : null
    };
    
    this.profileId = null;
    this.isOwn = false;
    this.settings = {};
    this.cacheManager = null;
  }
  
  /**
   * Initialize the analyzer
   * @param {string} profileId - LinkedIn profile ID
   * @param {boolean} isOwn - Whether this is the user's own profile
   * @param {Object} settings - Extension settings
   */
  async init(profileId, isOwn, settings) {
    this.profileId = profileId;
    this.isOwn = isOwn;
    this.settings = settings;
    
    // Initialize cache manager
    this.cacheManager = new CacheManager(settings.cacheDuration || 7);
    
    // Log initialization settings for debugging
    Logger.info('[Analyzer] Initialized with settings:', {
      profileId: this.profileId,
      isOwn: this.isOwn,
      enableAI: this.settings.enableAI,
      hasApiKey: !!(this.settings.apiKey || this.settings.encryptedApiKey),
      aiProvider: this.settings.aiProvider,
      settingsKeys: Object.keys(this.settings)
    });
    
    // Log extractor status
    Logger.info('[Analyzer] Extractor load status:', {
      loaded: Object.keys(this.extractors).filter(key => this.extractors[key] !== null),
      missing: Object.keys(this.extractors).filter(key => this.extractors[key] === null),
      total: Object.keys(this.extractors).length
    });
  }
  
  /**
   * Run the analysis
   * @param {boolean} forceRefresh - Force refresh even if cached
   */
  async analyze(forceRefresh = false) {
    try {
      Logger.info('[Analyzer] Starting analysis', { 
        profileId: this.profileId, 
        isOwn: this.isOwn,
        forceRefresh 
      });
      
      // Update overlay state
      OverlayManager.setState(OverlayManager.states.SCANNING);
      
      // Check cache first (unless forced refresh)
      if (!forceRefresh) {
        const cachedData = await this.cacheManager.get(this.profileId);
        if (cachedData && cachedData.completeness !== undefined) {
          Logger.info('[Analyzer] Using cached data');
          
          OverlayManager.setState(OverlayManager.states.CACHE_LOADED, {
            ...cachedData,
            fromCache: true,
            aiDisabled: !this.settings.enableAI
          });
          
          return { success: true, fromCache: true, data: cachedData };
        }
      }
      
      // Run extractors
      const extractedData = await this.runExtractors();
      
      // Calculate completeness
      OverlayManager.setState(OverlayManager.states.CALCULATING);
      const completenessData = await this.calculateCompleteness(extractedData);
      
      // Prepare result
      const result = {
        profileId: this.profileId,
        completeness: completenessData.score,
        completenessData: completenessData,
        extractedData: extractedData,
        timestamp: new Date().toISOString()
      };
      
      // Run AI analysis if enabled
      const hasApiKey = this.settings.apiKey || this.settings.encryptedApiKey;
      
      // Pre-check logging for debugging
      Logger.info('[Analyzer] Pre-AI check:', {
        enableAI: this.settings.enableAI,
        enableAIType: typeof this.settings.enableAI,
        apiKey: !!this.settings.apiKey,
        encryptedApiKey: !!this.settings.encryptedApiKey,
        hasApiKey: !!hasApiKey,
        aiProvider: this.settings.aiProvider,
        aiProviderType: typeof this.settings.aiProvider,
        condition: !!(this.settings.enableAI && hasApiKey && this.settings.aiProvider)
      });
      
      if (this.settings.enableAI && hasApiKey && this.settings.aiProvider) {
        Logger.info('[Analyzer] Starting AI analysis', {
          enableAI: this.settings.enableAI,
          hasApiKey: !!hasApiKey,
          aiProvider: this.settings.aiProvider
        });
        
        OverlayManager.setState(OverlayManager.states.AI_ANALYZING);
        
        const aiResult = await this.runAIAnalysis(extractedData);
        if (aiResult.success) {
          result.contentScore = aiResult.score;
          result.recommendations = aiResult.recommendations;
          result.insights = aiResult.insights;
          result.sectionScores = aiResult.sectionScores;
          
          Logger.info('[Analyzer] AI Result Details:', {
            score: aiResult.score,
            recommendations: aiResult.recommendations,
            insights: aiResult.insights,
            fullResult: aiResult
          });
          
          Logger.info('[Analyzer] AI analysis successful:', {
            contentScore: result.contentScore,
            hasRecommendations: !!result.recommendations,
            hasInsights: !!result.insights,
            hasSectionScores: !!result.sectionScores
          });
        } else {
          Logger.error('[Analyzer] AI analysis failed:', aiResult.error);
          // Don't fail the whole analysis, just note AI failed
          result.aiError = {
            message: aiResult.error,
            type: aiResult.errorType,
            retryAfter: aiResult.retryAfter
          };
        }
      } else {
        Logger.info('[Analyzer] Skipping AI analysis', {
          enableAI: this.settings.enableAI,
          hasApiKey: !!hasApiKey,
          aiProvider: this.settings.aiProvider
        });
      }
      
      // Save to cache
      await this.cacheManager.save(this.profileId, result, extractedData);
      
      // Update overlay with final results
      // If AI failed but we have completeness, show complete state with error
      const finalState = result.aiError && this.settings.enableAI ? 
        OverlayManager.states.ERROR : 
        OverlayManager.states.COMPLETE;
      
      OverlayManager.setState(finalState, {
        ...result,
        aiDisabled: !this.settings.enableAI
      });
      
      return { success: true, data: result };
      
    } catch (error) {
      Logger.error('[Analyzer] Analysis failed:', error);
      OverlayManager.setState(OverlayManager.states.ERROR, {
        message: error.message
      });
      return { success: false, error: error.message };
    }
  }
  
  /**
   * Run all extractors
   */
  async runExtractors() {
    Logger.info('[Analyzer] Running extractors');
    const results = {};
    
    // Update scan progress
    const sections = Object.keys(this.extractors).map(name => ({
      name,
      status: 'pending',
      itemCount: 0
    }));
    
    OverlayManager.updateScanProgress(sections);
    
    // Run extractors in parallel
    const promises = Object.entries(this.extractors).map(async ([name, extractor]) => {
      if (!extractor) {
        Logger.warn(`[Analyzer] ${name} extractor not loaded`);
        return { name, data: null };
      }
      
      try {
        // Update status to scanning
        sections.find(s => s.name === name).status = 'scanning';
        OverlayManager.updateScanProgress(sections);
        
        // Run scan
        const scanResult = await extractor.scan();
        
        // Update status to complete
        const section = sections.find(s => s.name === name);
        section.status = 'complete';
        section.itemCount = scanResult.totalCount || scanResult.count || 0;
        OverlayManager.updateScanProgress(sections);
        
        // Run extraction if section exists
        if (scanResult.exists) {
          OverlayManager.setState(OverlayManager.states.EXTRACTING);
          OverlayManager.updateExtractionProgress(name);
          
          const extractResult = await extractor.extract();
          return { name, data: extractResult };
        }
        
        return { name, data: scanResult };
        
      } catch (error) {
        Logger.error(`[Analyzer] ${name} extraction failed:`, error);
        return { name, data: null, error: error.message };
      }
    });
    
    const extractorResults = await Promise.all(promises);
    
    // Compile results
    extractorResults.forEach(({ name, data }) => {
      results[name] = data;
    });
    
    Logger.info('[Analyzer] Extraction complete', { 
      sections: Object.keys(results).filter(k => results[k]?.exists).length 
    });
    
    return results;
  }
  
  /**
   * Calculate completeness score
   */
  async calculateCompleteness(extractedData) {
    if (typeof ProfileCompletenessCalculator !== 'undefined') {
      const calculator = new ProfileCompletenessCalculator();
      return calculator.calculate(extractedData);
    }
    
    // Fallback calculation
    Logger.warn('[Analyzer] ProfileCompletenessCalculator not available, using fallback');
    return {
      score: 50,
      recommendations: [],
      breakdown: {}
    };
  }
  
  /**
   * Run distributed AI analysis (section by section)
   */
  async runDistributedAIAnalysis(extractedData) {
    Logger.info('[Analyzer] Starting distributed AI analysis');
    
    const sectionPromises = [];
    const sectionResults = {};
    const sectionRecommendations = {};
    
    // 1. Analyze Profile Intro (About + Headline + Photo)
    if (extractedData.headline || extractedData.about) {
      sectionPromises.push(
        this.analyzeSection('profile_intro', {
          headline: extractedData.headline,
          about: extractedData.about,
          photo: extractedData.photo,
          topSkills: extractedData.skills?.skills?.slice(0, 10).map(s => s.name || s.skill)
        })
      );
    }
    
    // 2. Analyze Each Experience Role
    if (extractedData.experience?.experiences?.length > 0) {
      extractedData.experience.experiences.forEach((exp, index) => {
        sectionPromises.push(
          this.analyzeSection('experience_role', exp, {
            position: index,
            totalRoles: extractedData.experience.experiences.length,
            previousRole: extractedData.experience.experiences[index - 1],
            nextRole: extractedData.experience.experiences[index + 1]
          })
        );
      });
    }
    
    // 3. Analyze Skills
    if (extractedData.skills) {
      sectionPromises.push(
        this.analyzeSection('skills', extractedData.skills)
      );
    }
    
    // 4. Analyze Recommendations
    if (extractedData.recommendations) {
      sectionPromises.push(
        this.analyzeSection('recommendations', extractedData.recommendations)
      );
    }
    
    // Execute all section analyses in parallel
    const results = await Promise.allSettled(sectionPromises);
    
    // Process results
    results.forEach((result, index) => {
      if (result.status === 'fulfilled' && result.value.success) {
        const section = result.value.section;
        sectionResults[section] = result.value;
        sectionRecommendations[section] = result.value.recommendations || [];
        
        // Update UI progressively
        OverlayManager.updateSectionScore(section, result.value.score);
      }
    });
    
    // 5. Synthesize all results
    const synthesis = await this.synthesizeResults(sectionResults, sectionRecommendations);
    
    return synthesis;
  }
  
  /**
   * Analyze individual section
   */
  async analyzeSection(sectionType, data, context = {}) {
    return new Promise((resolve) => {
      safeSendMessage({
        action: 'analyzeSectionAI',
        section: sectionType,
        data: data,
        context: context,
        settings: this.settings
      }, (response) => {
        if (response && response.success) {
          resolve({
            success: true,
            section: sectionType,
            score: response.score,
            analysis: response.analysis,
            recommendations: response.recommendations,
            insights: response.insights
          });
        } else {
          resolve({
            success: false,
            section: sectionType,
            error: response?.error || 'Section analysis failed'
          });
        }
      });
    });
  }
  
  /**
   * Synthesize all section results
   */
  async synthesizeResults(sectionResults, sectionRecommendations) {
    return new Promise((resolve) => {
      safeSendMessage({
        action: 'synthesizeAnalysis',
        sectionScores: sectionResults,
        sectionRecommendations: sectionRecommendations
      }, (response) => {
        if (response && response.success) {
          resolve({
            success: true,
            score: response.finalScore,
            synthesis: response.synthesis,
            recommendations: response.overallRecommendations,
            insights: response.careerNarrative
          });
        } else {
          // Fallback: calculate weighted average
          const weights = {
            profile_intro: 0.25,
            experience: 0.40,
            skills: 0.20,
            recommendations: 0.15
          };
          
          let totalScore = 0;
          let totalWeight = 0;
          
          Object.entries(sectionResults).forEach(([section, result]) => {
            const weight = weights[section] || 0.1;
            totalScore += (result.score || 0) * weight;
            totalWeight += weight;
          });
          
          resolve({
            success: true,
            score: totalWeight > 0 ? totalScore / totalWeight : 5,
            recommendations: Object.values(sectionRecommendations).flat(),
            insights: { message: 'Synthesis unavailable, showing section results' }
          });
        }
      });
    });
  }
  
  /**
   * Run AI analysis (legacy monolithic approach)
   */
  async runAIAnalysis(extractedData) {
    // Try distributed approach first
    try {
      const distributedResult = await this.runDistributedAIAnalysis(extractedData);
      if (distributedResult.success) {
        return distributedResult;
      }
    } catch (error) {
      Logger.warn('[Analyzer] Distributed analysis failed, falling back to monolithic', error);
    }
    
    // Fallback to original monolithic approach
    Logger.info('[Analyzer] Using monolithic AI analysis', {
      hasData: !!extractedData,
      dataKeys: Object.keys(extractedData || {}),
      settingsKeys: Object.keys(this.settings || {})
    });
    
    return new Promise((resolve) => {
      safeSendMessage({
        action: 'analyzeWithAI',
        data: extractedData,
        settings: this.settings
      }, (response) => {
        Logger.info('[Analyzer] AI analysis response received', {
          success: response?.success,
          hasScore: !!response?.score,
          error: response?.error,
          errorType: response?.errorType
        });
        
        if (response && response.success) {
          Logger.info('[Analyzer] Full AI response:', response);
          resolve({
            success: true,
            score: response.score,
            recommendations: response.recommendations,
            insights: response.insights,
            sectionScores: response.sectionScores,
            summary: response.summary
          });
        } else {
          resolve({
            success: false,
            error: response?.error || 'AI analysis failed',
            errorType: response?.errorType,
            retryAfter: response?.retryAfter
          });
        }
      });
    });
  }
}


  /* ============================================
   * MODULE: analyzer-main.js
   * ============================================ */
/**
 * Main entry point for ElevateLI content script
 * Coordinates all modules and initializes the extension
 */

// Note: All dependencies are assumed to be available in global scope
// from previously loaded modules in the concatenated analyzer.js

// Wrap in IIFE to avoid global scope pollution
(function() {
  'use strict';
  
  console.log(`${CONFIG.EXTENSION_NAME} content script loaded`);
  
  // Check if extension context is still valid
  function isExtensionContextValid() {
    return !!(chrome?.runtime?.id);
  }
  
  // Initialize the extension
  function init() {
    console.log('[INFO] Initializing ElevateLI', { url: location.href });
    
    // Check if extension context is still valid
    if (!isExtensionContextValid()) {
      console.warn('[WARN] Extension context invalidated - old content script instance');
      return;
    }
    
    // Check if we're on a LinkedIn profile page
    if (!isProfilePage()) {
      console.log('[INFO] Not a profile page, skipping initialization');
      return;
    }
    
    // Get profile ID from URL
    const profileId = getProfileIdFromUrl();
    if (!profileId) {
      console.log('[WARN] Could not extract profile ID from URL');
      return;
    }
    
    console.log('[INFO] Profile ID:', profileId);
    
    // Check if it's the user's own profile
    isOwnProfile().then(isOwn => {
      console.log('[INFO] Is own profile:', isOwn);
      
      // Only initialize overlay on user's own profile
      if (!isOwn) {
        console.log('[INFO] Not user\'s profile - skipping overlay injection');
        return;
      }
      
      // Check if user has accepted terms
      if (!isExtensionContextValid()) {
        console.warn('[WARN] Extension context invalidated before checking compliance');
        return;
      }
      
      chrome.storage.local.get(['compliance', 'userProfile'], async (data) => {
        // Check for runtime errors
        if (chrome.runtime.lastError) {
          console.warn('[WARN] Failed to check compliance:', chrome.runtime.lastError);
          return;
        }
        
        if (!data.compliance?.hasAcknowledged) {
          console.log('[INFO] Terms not accepted - skipping overlay injection');
          return;
        }
        
        // Initialize overlay only after all checks pass
        OverlayManager.initialize();
        
        // Use saved profile ID for cache if available, otherwise use URL
        const cacheProfileId = data.userProfile?.profileId || profileId;
        console.log('[INFO] Using profile ID for cache:', cacheProfileId);
        
        // Get settings and check cache
        chrome.storage.local.get(['enableAI', 'apiKey', 'encryptedApiKey', 'aiProvider', 'cacheDuration'], async (settings) => {
          const hasApiKey = settings.apiKey || settings.encryptedApiKey;
          const enableAI = settings.enableAI && hasApiKey && settings.aiProvider;
          
          // Check cache first
          const cacheManager = new CacheManager(settings.cacheDuration || 7);
          const cachedData = await cacheManager.get(cacheProfileId);
          
          if (cachedData && cachedData.completeness !== undefined) {
            console.log('[INFO] Found cached data', { 
              completeness: cachedData.completeness,
              contentScore: cachedData.contentScore,
              fromCache: true
            });
            
            // Show cached results
            OverlayManager.setState(OverlayManager.states.CACHE_LOADED, {
              completeness: cachedData.completeness,
              contentScore: cachedData.contentScore,
              completenessData: cachedData.completenessData,
              recommendations: cachedData.recommendations,
              timestamp: cachedData.timestamp,
              fromCache: true,
              aiDisabled: !enableAI
            });
          } else {
            // No cache - show empty state
            console.log('[INFO] No cache found, showing empty state');
            OverlayManager.setState(OverlayManager.states.EMPTY_CACHE);
          }
        });
      });
    });
  }
  
  // Extract profile ID from URL
  function getProfileIdFromUrl() {
    const path = window.location.pathname;
    const match = path.match(/\/in\/([^\/]+)/);
    return match ? match[1] : null;
  }
  
  // Start analysis when requested
  async function startAnalysis(forceRefresh = false) {
    console.log('[INFO] Starting analysis', { forceRefresh });
    
    // Check if extension context is still valid
    if (!isExtensionContextValid()) {
      console.warn('[WARN] Extension context invalidated - cannot start analysis');
      return;
    }
    
    const profileId = getProfileIdFromUrl();
    if (!profileId) return;
    
    // Get saved profile for consistent cache key
    const savedProfile = await getSavedProfile();
    const cacheProfileId = savedProfile?.profileId || profileId;
    
    const isOwn = await isOwnProfile();
    
    let settings = {};
    try {
      settings = await new Promise((resolve, reject) => {
        if (!isExtensionContextValid()) {
          resolve({});
          return;
        }
        chrome.storage.local.get(['enableAI', 'apiKey', 'encryptedApiKey', 'aiProvider', 'cacheDuration'], (data) => {
          if (chrome.runtime.lastError) {
            console.warn('[WARN] Failed to get settings:', chrome.runtime.lastError);
            resolve({});
          } else {
            resolve(data);
          }
        });
      });
    } catch (error) {
      console.warn('[WARN] Error getting settings:', error);
      settings = {};
    }
    
    // Log settings for debugging
    console.log('[INFO] Settings loaded:', {
      enableAI: settings.enableAI,
      hasApiKey: !!(settings.apiKey || settings.encryptedApiKey),
      apiKeyType: settings.apiKey ? 'plain' : settings.encryptedApiKey ? 'encrypted' : 'none',
      aiProvider: settings.aiProvider,
      cacheDuration: settings.cacheDuration
    });
    
    // Create analyzer instance with consistent cache profile ID
    const analyzer = new Analyzer();
    await analyzer.init(cacheProfileId, isOwn, settings);
    
    // Run analysis
    const results = await analyzer.analyze(forceRefresh);
    
    if (results.success) {
      console.log('[INFO] Analysis complete', results);
    } else {
      console.error('[ERROR] Analysis failed', results.error);
    }
  }
  
  // Listen for messages from popup/background
  window.addEventListener('message', (event) => {
    if (event.source !== window) return;
    
    if (event.data.type === 'ELEVATE_REFRESH') {
      console.log('[INFO] Refresh requested via overlay');
      startAnalysis(true);
    }
  });
  
  // Navigation observer for SPA navigation
  function observeNavigation() {
    let lastPath = location.pathname;
    
    const observer = new MutationObserver(debounce(() => {
      if (location.pathname !== lastPath) {
        lastPath = location.pathname;
        console.log('[INFO] Navigation detected', { newPath: lastPath });
        
        // Cleanup previous overlay
        const existingOverlay = document.querySelector('.elevateli-overlay-wrapper');
        if (existingOverlay) {
          existingOverlay.remove();
        }
        
        // Reinitialize if still on a profile page
        if (isProfilePage()) {
          setTimeout(init, 500);
        }
      }
    }, 500));
    
    observer.observe(document.body, {
      childList: true,
      subtree: true
    });
  }
  
  // Chrome runtime message listener
  if (chrome.runtime && chrome.runtime.onMessage) {
    chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
      console.log('[INFO] Received message:', request);
      
      if (request.action === 'analyzeProfile') {
        startAnalysis(request.forceRefresh).then(() => {
          sendResponse({ success: true });
        }).catch(error => {
          sendResponse({ success: false, error: error.message });
        });
        return true; // Keep channel open for async response
      }
      
      if (request.action === 'getProfileData') {
        const profileId = getProfileIdFromUrl();
        chrome.storage.local.get([`cache_${profileId}`], (data) => {
          sendResponse({ 
            success: true, 
            data: data[`cache_${profileId}`] || null 
          });
        });
        return true;
      }
      
      if (request.action === 'profileUpdated') {
        console.log('[INFO] Profile updated notification received');
        const currentProfileId = getProfileIdFromUrl();
        
        if (currentProfileId === request.userProfile.profileId) {
          console.log('[INFO] Current page matches saved profile, initializing overlay');
          
          // Check if overlay already exists
          if (!document.querySelector('.elevateli-overlay-wrapper')) {
            // Re-run initialization
            init();
            sendResponse({ success: true, overlayInitialized: true });
          } else {
            console.log('[INFO] Overlay already exists');
            sendResponse({ success: true, overlayExists: true });
          }
        } else {
          console.log('[INFO] Current page does not match saved profile');
          sendResponse({ success: false, reason: 'Profile mismatch' });
        }
        return true;
      }
    });
  }
  
  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
  
  // Start navigation observer
  observeNavigation();
  
  // Export for debugging
  window.ElevateLI = {
    startAnalysis,
    getProfileId: getProfileIdFromUrl,
    OverlayManager,
    Analyzer: typeof Analyzer !== 'undefined' ? Analyzer : null
  };
  
})();

})();
